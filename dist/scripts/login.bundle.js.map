{"version":3,"sources":["webpack:///scripts/login.bundle.js","webpack:///./src/app/components/login/login.js","webpack:///./src/app/components/login/rsautils.js"],"names":["webpackJsonp",0,"module","exports","__webpack_require__","$","effectStart","AMUI","progress","set","$loginBtn","button","effectDone","done","Utils","RSAUtils","CEIS","post","URL","RSA_KEY","data","content","exponent","e","modulus","n","on","setTimeout","this","modal","bind","$username","val","trim","toUpperCase","img","prev","src","VALIDATA_IMG","Math","random","submit","ev","preventDefault","$password","$validate","pwd_str","act_str","vali_str","html","is","$loginForm","key","getKeyPair","encryptedPwd","encryptedString","LOGIN","serializeArray","status","sessionid","firstLogin","storage","forward","msg","shiroLoginFailure","show","click","always","call",13,18,"BarrettMu_modulo","x","$dmath","q1","biDivideByRadixPower","k","q2","biMultiply","mu","q3","r1","biModuloByRadixPower","r2term","r2","r","biSubtract","isNeg","biAdd","bkplus1","rgtem","biCompare","BarrettMu_multiplyMod","y","xy","modulo","BarrettMu_powMod","result","BigInt","digits","a","multiplyMod","biShiftRight","biHighIndex","maxDigits","ZERO_ARRAY","bigZero","bigOne","biRadixBits","bitsPerDigit","biRadix","biHalfRadix","biRadixSquared","maxDigitVal","flag","slice","setMaxDigits","value","Array","iza","length","dpl10","biFromNumber","i","abs","j","floor","lr10","biFromDecimal","s","charAt","digitCount","fgl","Number","substr","biCopy","bi","reverseStr","hexatrigesimalToChar","biToString","radix","b","qr","biDivideModulo","digit","biToDecimal","String","hexToChar","digitToHex","mask","biToHex","charToHex","c","ZERO","NINE","littleA","littleZ","bigA","bigZ","hexToDigit","sl","min","charCodeAt","biFromHex","max","biFromString","istop","place","biDigit","biMultiplyDigit","biDump","join","biNumBits","d","m","uv","t","arrayCopy","srcStart","dest","destStart","highBitMasks","biShiftLeft","bits","rightBits","i1","lowBitMasks","leftBits","biMultiplyByRadixPower","q","nb","tb","origYIsNeg","ceil","lambda","ri","ri1","ri2","yt","yt1","c1","c2","biDivide","biModulo","biMultiplyMod","biPow","biPowMod","BarrettMu","b2k","powMod","RSAKeyPair","encryptionExponent","decryptionExponent","chunkSize","barrett","twoDigit","block","al","crypt","text","substring","decryptedString","blocks","split","fromCharCode"],"mappings":"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","file":"./scripts/login.bundle.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function($) {\r\n\tvar Utils = __webpack_require__(2)\r\n\t__webpack_require__(3)\r\n\t__webpack_require__(13)\r\n\t\r\n\tvar RSAUtils = __webpack_require__(18)\r\n\tvar CEIS = {}\r\n\t\r\n\t$.post(Utils.URL.RSA_KEY)\r\n\t .done(function(data) {\r\n\t  if (data && data.content) {\r\n\t    CEIS.exponent = data.content.e;\r\n\t    CEIS.modulus = data.content.n;\r\n\t  }\r\n\t })\r\n\t\r\n\t$('#toast').on('opened.modal.amui', function() {\r\n\t  setTimeout(function() {\r\n\t    $(this).modal('close')\r\n\t  }.bind(this), 1000)\r\n\t})\r\n\t\r\n\t$('#username').on('change', function() {\r\n\t  var $username = $(this);\r\n\t  $username.val($.trim($username.val()).toUpperCase());\r\n\t})\r\n\t\r\n\t$('#validateCodeDiv').on('click', 'a', function() {\r\n\t  var img = $(this).prev()[0]\r\n\t  img.src = Utils.URL.VALIDATA_IMG + '?' + Math.random()\r\n\t})\r\n\t\r\n\tvar $loginBtn = $('#loginBtn')\r\n\t\r\n\tfunction effectStart() {\r\n\t  $.AMUI.progress.set(0.8)\r\n\t  $loginBtn.button('loading')\r\n\t}\r\n\t\r\n\tfunction effectDone() {\r\n\t  $.AMUI.progress.done()\r\n\t  $loginBtn.button('reset')\r\n\t}\r\n\t\r\n\t$('#loginForm').submit(function(ev) {\r\n\t  ev.preventDefault()\r\n\t\r\n\t  var $username = $('#username')\r\n\t  var $password = $('#password')\r\n\t  var $validate = $('#validateCode')\r\n\t  var pwd_str = $.trim($password.val()),\r\n\t      act_str = $.trim($username.val()),\r\n\t      vali_str = $.trim($validate.val())\r\n\t\r\n\t  if (act_str === '') {\r\n\t    $('#toast-cnt').html('请填写用户名')\r\n\t    $('#toast').modal('open')\r\n\t  }\r\n\t  else if (pwd_str === '') {\r\n\t    $('#toast-cnt').html('请填写密码')\r\n\t    $('#toast').modal('open')\r\n\t  }\r\n\t  else if ($('#validateCodeDiv').is(':visible') && vali_str === '') {\r\n\t    $('#toast-cnt').html('请填写验证码')\r\n\t    $('#toast').modal('open')\r\n\t  }\r\n\t  else {\r\n\t    effectStart()\r\n\t\r\n\t    var $loginForm = $(this)\r\n\t    if (CEIS.exponent && CEIS.modulus) {\r\n\t      var key = RSAUtils.getKeyPair(CEIS.exponent, '', CEIS.modulus);\r\n\t      var encryptedPwd = RSAUtils.encryptedString(key, pwd_str);\r\n\t      $password.val(encryptedPwd);\r\n\t    }\r\n\t\r\n\t    $.post(Utils.URL.LOGIN, $loginForm.serializeArray())\r\n\t     .done(function(data) {\r\n\t       if (data && data.status === 'success') {\r\n\t         CEIS.sessionid = data.content.sessionid;\r\n\t         CEIS.firstLogin = data.content.firstLogin;\r\n\t         Utils.storage.set('ceis', CEIS.sessionid)\r\n\t         if (CEIS.firstLogin) {\r\n\t           $('#toast-cnt').html('首次登陆或密码过期，请修改密码！')\r\n\t           $('#toast').modal('open')\r\n\t           Utils.forward('./modifypwd.html')\r\n\t         }\r\n\t         else {\r\n\t           $('#toast-cnt').html('登录成功！')\r\n\t           $('#toast').modal('open')\r\n\t           Utils.forward('./index.html')\r\n\t         }\r\n\t       }\r\n\t       else {\r\n\t         $password.val('')\r\n\t         $('#toast-cnt').html(data.msg)\r\n\t         $('#toast').modal('open')\r\n\t         effectDone()\r\n\t\r\n\t         if (data.content && data.content.shiroLoginFailure == 'org.apache.shiro.authc.AuthenticationException'){\r\n\t           $('#validateCodeDiv').show()\r\n\t         }\r\n\t         $('#validateCodeDiv a').click()\r\n\t       }\r\n\t     })\r\n\t     .always(function(data) {\r\n\t       effectDone()\r\n\t     })\r\n\t\r\n\t    // setTimeout(function() {\r\n\t    //   $.AMUI.progress.done()\r\n\t    //   document.location.href = 'index.html'\r\n\t    // }, 1500)\r\n\t  }\r\n\t\r\n\t})\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n\n/***/ 13:\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n\n/***/ 18:\n/***/ function(module, exports) {\n\n\t/*\r\n\t * RSA, a suite of routines for performing RSA public-key computations in JavaScript.\r\n\t * Copyright 1998-2005 David Shapiro.\r\n\t * Dave Shapiro\r\n\t * dave@ohdave.com\r\n\t * changed by Fuchun, 2010-05-06\r\n\t * fcrpg2005@gmail.com\r\n\t */\r\n\t\r\n\tvar RSAUtils = {};\r\n\t\r\n\tvar biRadixBase = 2;\r\n\tvar biRadixBits = 16;\r\n\tvar bitsPerDigit = biRadixBits;\r\n\tvar biRadix = 1 << 16; // = 2^16 = 65536\r\n\tvar biHalfRadix = biRadix >>> 1;\r\n\tvar biRadixSquared = biRadix * biRadix;\r\n\tvar maxDigitVal = biRadix - 1;\r\n\tvar maxInteger = 9999999999999998;\r\n\t\r\n\t//maxDigits:\r\n\t//Change this to accommodate your largest number size. Use setMaxDigits()\r\n\t//to change it!\r\n\t//\r\n\t//In general, if you're working with numbers of size N bits, you'll need 2*N\r\n\t//bits of storage. Each digit holds 16 bits. So, a 1024-bit key will need\r\n\t//\r\n\t//1024 * 2 / 16 = 128 digits of storage.\r\n\t//\r\n\tvar maxDigits;\r\n\tvar ZERO_ARRAY;\r\n\tvar bigZero, bigOne;\r\n\t\r\n\tvar BigInt = BigInt = function(flag) {\r\n\t\tif (typeof flag == \"boolean\" && flag == true) {\r\n\t\t\tthis.digits = null;\r\n\t\t} else {\r\n\t\t\tthis.digits = ZERO_ARRAY.slice(0);\r\n\t\t}\r\n\t\tthis.isNeg = false;\r\n\t};\r\n\t\r\n\tRSAUtils.setMaxDigits = function(value) {\r\n\t\tmaxDigits = value;\r\n\t\tZERO_ARRAY = new Array(maxDigits);\r\n\t\tfor (var iza = 0; iza < ZERO_ARRAY.length; iza++) ZERO_ARRAY[iza] = 0;\r\n\t\tbigZero = new BigInt();\r\n\t\tbigOne = new BigInt();\r\n\t\tbigOne.digits[0] = 1;\r\n\t};\r\n\tRSAUtils.setMaxDigits(20);\r\n\t\r\n\t//The maximum number of digits in base 10 you can convert to an\r\n\t//integer without JavaScript throwing up on you.\r\n\tvar dpl10 = 15;\r\n\t\r\n\tRSAUtils.biFromNumber = function(i) {\r\n\t\tvar result = new BigInt();\r\n\t\tresult.isNeg = i < 0;\r\n\t\ti = Math.abs(i);\r\n\t\tvar j = 0;\r\n\t\twhile (i > 0) {\r\n\t\t\tresult.digits[j++] = i & maxDigitVal;\r\n\t\t\ti = Math.floor(i / biRadix);\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\t//lr10 = 10 ^ dpl10\r\n\tvar lr10 = RSAUtils.biFromNumber(1000000000000000);\r\n\t\r\n\tRSAUtils.biFromDecimal = function(s) {\r\n\t\tvar isNeg = s.charAt(0) == '-';\r\n\t\tvar i = isNeg ? 1 : 0;\r\n\t\tvar result;\r\n\t\t// Skip leading zeros.\r\n\t\twhile (i < s.length && s.charAt(i) == '0') ++i;\r\n\t\tif (i == s.length) {\r\n\t\t\tresult = new BigInt();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tvar digitCount = s.length - i;\r\n\t\t\tvar fgl = digitCount % dpl10;\r\n\t\t\tif (fgl == 0) fgl = dpl10;\r\n\t\t\tresult = RSAUtils.biFromNumber(Number(s.substr(i, fgl)));\r\n\t\t\ti += fgl;\r\n\t\t\twhile (i < s.length) {\r\n\t\t\t\tresult = RSAUtils.biAdd(RSAUtils.biMultiply(result, lr10),\r\n\t\t\t\t\t\tRSAUtils.biFromNumber(Number(s.substr(i, dpl10))));\r\n\t\t\t\ti += dpl10;\r\n\t\t\t}\r\n\t\t\tresult.isNeg = isNeg;\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biCopy = function(bi) {\r\n\t\tvar result = new BigInt(true);\r\n\t\tresult.digits = bi.digits.slice(0);\r\n\t\tresult.isNeg = bi.isNeg;\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.reverseStr = function(s) {\r\n\t\tvar result = \"\";\r\n\t\tfor (var i = s.length - 1; i > -1; --i) {\r\n\t\t\tresult += s.charAt(i);\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tvar hexatrigesimalToChar = [\r\n\t\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n\t\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\r\n\t\t'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\r\n\t\t'u', 'v', 'w', 'x', 'y', 'z'\r\n\t];\r\n\t\r\n\tRSAUtils.biToString = function(x, radix) { // 2 <= radix <= 36\r\n\t\tvar b = new BigInt();\r\n\t\tb.digits[0] = radix;\r\n\t\tvar qr = RSAUtils.biDivideModulo(x, b);\r\n\t\tvar result = hexatrigesimalToChar[qr[1].digits[0]];\r\n\t\twhile (RSAUtils.biCompare(qr[0], bigZero) == 1) {\r\n\t\t\tqr = RSAUtils.biDivideModulo(qr[0], b);\r\n\t\t\tdigit = qr[1].digits[0];\r\n\t\t\tresult += hexatrigesimalToChar[qr[1].digits[0]];\r\n\t\t}\r\n\t\treturn (x.isNeg ? \"-\" : \"\") + RSAUtils.reverseStr(result);\r\n\t};\r\n\t\r\n\tRSAUtils.biToDecimal = function(x) {\r\n\t\tvar b = new BigInt();\r\n\t\tb.digits[0] = 10;\r\n\t\tvar qr = RSAUtils.biDivideModulo(x, b);\r\n\t\tvar result = String(qr[1].digits[0]);\r\n\t\twhile (RSAUtils.biCompare(qr[0], bigZero) == 1) {\r\n\t\t\tqr = RSAUtils.biDivideModulo(qr[0], b);\r\n\t\t\tresult += String(qr[1].digits[0]);\r\n\t\t}\r\n\t\treturn (x.isNeg ? \"-\" : \"\") + RSAUtils.reverseStr(result);\r\n\t};\r\n\t\r\n\tvar hexToChar = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n\t        'a', 'b', 'c', 'd', 'e', 'f'];\r\n\t\r\n\tRSAUtils.digitToHex = function(n) {\r\n\t\tvar mask = 0xf;\r\n\t\tvar result = \"\";\r\n\t\tfor (i = 0; i < 4; ++i) {\r\n\t\t\tresult += hexToChar[n & mask];\r\n\t\t\tn >>>= 4;\r\n\t\t}\r\n\t\treturn RSAUtils.reverseStr(result);\r\n\t};\r\n\t\r\n\tRSAUtils.biToHex = function(x) {\r\n\t\tvar result = \"\";\r\n\t\tvar n = RSAUtils.biHighIndex(x);\r\n\t\tfor (var i = RSAUtils.biHighIndex(x); i > -1; --i) {\r\n\t\t\tresult += RSAUtils.digitToHex(x.digits[i]);\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.charToHex = function(c) {\r\n\t\tvar ZERO = 48;\r\n\t\tvar NINE = ZERO + 9;\r\n\t\tvar littleA = 97;\r\n\t\tvar littleZ = littleA + 25;\r\n\t\tvar bigA = 65;\r\n\t\tvar bigZ = 65 + 25;\r\n\t\tvar result;\r\n\t\r\n\t\tif (c >= ZERO && c <= NINE) {\r\n\t\t\tresult = c - ZERO;\r\n\t\t} else if (c >= bigA && c <= bigZ) {\r\n\t\t\tresult = 10 + c - bigA;\r\n\t\t} else if (c >= littleA && c <= littleZ) {\r\n\t\t\tresult = 10 + c - littleA;\r\n\t\t} else {\r\n\t\t\tresult = 0;\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.hexToDigit = function(s) {\r\n\t\tvar result = 0;\r\n\t\tvar sl = Math.min(s.length, 4);\r\n\t\tfor (var i = 0; i < sl; ++i) {\r\n\t\t\tresult <<= 4;\r\n\t\t\tresult |= RSAUtils.charToHex(s.charCodeAt(i));\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biFromHex = function(s) {\r\n\t\tvar result = new BigInt();\r\n\t\tvar sl = s.length;\r\n\t\tfor (var i = sl, j = 0; i > 0; i -= 4, ++j) {\r\n\t\t\tresult.digits[j] = RSAUtils.hexToDigit(s.substr(Math.max(i - 4, 0), Math.min(i, 4)));\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biFromString = function(s, radix) {\r\n\t\tvar isNeg = s.charAt(0) == '-';\r\n\t\tvar istop = isNeg ? 1 : 0;\r\n\t\tvar result = new BigInt();\r\n\t\tvar place = new BigInt();\r\n\t\tplace.digits[0] = 1; // radix^0\r\n\t\tfor (var i = s.length - 1; i >= istop; i--) {\r\n\t\t\tvar c = s.charCodeAt(i);\r\n\t\t\tvar digit = RSAUtils.charToHex(c);\r\n\t\t\tvar biDigit = RSAUtils.biMultiplyDigit(place, digit);\r\n\t\t\tresult = RSAUtils.biAdd(result, biDigit);\r\n\t\t\tplace = RSAUtils.biMultiplyDigit(place, radix);\r\n\t\t}\r\n\t\tresult.isNeg = isNeg;\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biDump = function(b) {\r\n\t\treturn (b.isNeg ? \"-\" : \"\") + b.digits.join(\" \");\r\n\t};\r\n\t\r\n\tRSAUtils.biAdd = function(x, y) {\r\n\t\tvar result;\r\n\t\r\n\t\tif (x.isNeg != y.isNeg) {\r\n\t\t\ty.isNeg = !y.isNeg;\r\n\t\t\tresult = RSAUtils.biSubtract(x, y);\r\n\t\t\ty.isNeg = !y.isNeg;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tresult = new BigInt();\r\n\t\t\tvar c = 0;\r\n\t\t\tvar n;\r\n\t\t\tfor (var i = 0; i < x.digits.length; ++i) {\r\n\t\t\t\tn = x.digits[i] + y.digits[i] + c;\r\n\t\t\t\tresult.digits[i] = n % biRadix;\r\n\t\t\t\tc = Number(n >= biRadix);\r\n\t\t\t}\r\n\t\t\tresult.isNeg = x.isNeg;\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biSubtract = function(x, y) {\r\n\t\tvar result;\r\n\t\tif (x.isNeg != y.isNeg) {\r\n\t\t\ty.isNeg = !y.isNeg;\r\n\t\t\tresult = RSAUtils.biAdd(x, y);\r\n\t\t\ty.isNeg = !y.isNeg;\r\n\t\t} else {\r\n\t\t\tresult = new BigInt();\r\n\t\t\tvar n, c;\r\n\t\t\tc = 0;\r\n\t\t\tfor (var i = 0; i < x.digits.length; ++i) {\r\n\t\t\t\tn = x.digits[i] - y.digits[i] + c;\r\n\t\t\t\tresult.digits[i] = n % biRadix;\r\n\t\t\t\t// Stupid non-conforming modulus operation.\r\n\t\t\t\tif (result.digits[i] < 0) result.digits[i] += biRadix;\r\n\t\t\t\tc = 0 - Number(n < 0);\r\n\t\t\t}\r\n\t\t\t// Fix up the negative sign, if any.\r\n\t\t\tif (c == -1) {\r\n\t\t\t\tc = 0;\r\n\t\t\t\tfor (var i = 0; i < x.digits.length; ++i) {\r\n\t\t\t\t\tn = 0 - result.digits[i] + c;\r\n\t\t\t\t\tresult.digits[i] = n % biRadix;\r\n\t\t\t\t\t// Stupid non-conforming modulus operation.\r\n\t\t\t\t\tif (result.digits[i] < 0) result.digits[i] += biRadix;\r\n\t\t\t\t\tc = 0 - Number(n < 0);\r\n\t\t\t\t}\r\n\t\t\t\t// Result is opposite sign of arguments.\r\n\t\t\t\tresult.isNeg = !x.isNeg;\r\n\t\t\t} else {\r\n\t\t\t\t// Result is same sign.\r\n\t\t\t\tresult.isNeg = x.isNeg;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biHighIndex = function(x) {\r\n\t\tvar result = x.digits.length - 1;\r\n\t\twhile (result > 0 && x.digits[result] == 0) --result;\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biNumBits = function(x) {\r\n\t\tvar n = RSAUtils.biHighIndex(x);\r\n\t\tvar d = x.digits[n];\r\n\t\tvar m = (n + 1) * bitsPerDigit;\r\n\t\tvar result;\r\n\t\tfor (result = m; result > m - bitsPerDigit; --result) {\r\n\t\t\tif ((d & 0x8000) != 0) break;\r\n\t\t\td <<= 1;\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biMultiply = function(x, y) {\r\n\t\tvar result = new BigInt();\r\n\t\tvar c;\r\n\t\tvar n = RSAUtils.biHighIndex(x);\r\n\t\tvar t = RSAUtils.biHighIndex(y);\r\n\t\tvar u, uv, k;\r\n\t\r\n\t\tfor (var i = 0; i <= t; ++i) {\r\n\t\t\tc = 0;\r\n\t\t\tk = i;\r\n\t\t\tfor (j = 0; j <= n; ++j, ++k) {\r\n\t\t\t\tuv = result.digits[k] + x.digits[j] * y.digits[i] + c;\r\n\t\t\t\tresult.digits[k] = uv & maxDigitVal;\r\n\t\t\t\tc = uv >>> biRadixBits;\r\n\t\t\t\t//c = Math.floor(uv / biRadix);\r\n\t\t\t}\r\n\t\t\tresult.digits[i + n + 1] = c;\r\n\t\t}\r\n\t\t// Someone give me a logical xor, please.\r\n\t\tresult.isNeg = x.isNeg != y.isNeg;\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biMultiplyDigit = function(x, y) {\r\n\t\tvar n, c, uv;\r\n\t\r\n\t\tresult = new BigInt();\r\n\t\tn = RSAUtils.biHighIndex(x);\r\n\t\tc = 0;\r\n\t\tfor (var j = 0; j <= n; ++j) {\r\n\t\t\tuv = result.digits[j] + x.digits[j] * y + c;\r\n\t\t\tresult.digits[j] = uv & maxDigitVal;\r\n\t\t\tc = uv >>> biRadixBits;\r\n\t\t\t//c = Math.floor(uv / biRadix);\r\n\t\t}\r\n\t\tresult.digits[1 + n] = c;\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.arrayCopy = function(src, srcStart, dest, destStart, n) {\r\n\t\tvar m = Math.min(srcStart + n, src.length);\r\n\t\tfor (var i = srcStart, j = destStart; i < m; ++i, ++j) {\r\n\t\t\tdest[j] = src[i];\r\n\t\t}\r\n\t};\r\n\t\r\n\tvar highBitMasks = [0x0000, 0x8000, 0xC000, 0xE000, 0xF000, 0xF800,\r\n\t        0xFC00, 0xFE00, 0xFF00, 0xFF80, 0xFFC0, 0xFFE0,\r\n\t        0xFFF0, 0xFFF8, 0xFFFC, 0xFFFE, 0xFFFF];\r\n\t\r\n\tRSAUtils.biShiftLeft = function(x, n) {\r\n\t\tvar digitCount = Math.floor(n / bitsPerDigit);\r\n\t\tvar result = new BigInt();\r\n\t\tRSAUtils.arrayCopy(x.digits, 0, result.digits, digitCount,\r\n\t\t          result.digits.length - digitCount);\r\n\t\tvar bits = n % bitsPerDigit;\r\n\t\tvar rightBits = bitsPerDigit - bits;\r\n\t\tfor (var i = result.digits.length - 1, i1 = i - 1; i > 0; --i, --i1) {\r\n\t\t\tresult.digits[i] = ((result.digits[i] << bits) & maxDigitVal) |\r\n\t\t\t                   ((result.digits[i1] & highBitMasks[bits]) >>>\r\n\t\t\t                    (rightBits));\r\n\t\t}\r\n\t\tresult.digits[0] = ((result.digits[i] << bits) & maxDigitVal);\r\n\t\tresult.isNeg = x.isNeg;\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tvar lowBitMasks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F,\r\n\t        0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF,\r\n\t        0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];\r\n\t\r\n\tRSAUtils.biShiftRight = function(x, n) {\r\n\t\tvar digitCount = Math.floor(n / bitsPerDigit);\r\n\t\tvar result = new BigInt();\r\n\t\tRSAUtils.arrayCopy(x.digits, digitCount, result.digits, 0,\r\n\t\t          x.digits.length - digitCount);\r\n\t\tvar bits = n % bitsPerDigit;\r\n\t\tvar leftBits = bitsPerDigit - bits;\r\n\t\tfor (var i = 0, i1 = i + 1; i < result.digits.length - 1; ++i, ++i1) {\r\n\t\t\tresult.digits[i] = (result.digits[i] >>> bits) |\r\n\t\t\t                   ((result.digits[i1] & lowBitMasks[bits]) << leftBits);\r\n\t\t}\r\n\t\tresult.digits[result.digits.length - 1] >>>= bits;\r\n\t\tresult.isNeg = x.isNeg;\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biMultiplyByRadixPower = function(x, n) {\r\n\t\tvar result = new BigInt();\r\n\t\tRSAUtils.arrayCopy(x.digits, 0, result.digits, n, result.digits.length - n);\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biDivideByRadixPower = function(x, n) {\r\n\t\tvar result = new BigInt();\r\n\t\tRSAUtils.arrayCopy(x.digits, n, result.digits, 0, result.digits.length - n);\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biModuloByRadixPower = function(x, n) {\r\n\t\tvar result = new BigInt();\r\n\t\tRSAUtils.arrayCopy(x.digits, 0, result.digits, 0, n);\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biCompare = function(x, y) {\r\n\t\tif (x.isNeg != y.isNeg) {\r\n\t\t\treturn 1 - 2 * Number(x.isNeg);\r\n\t\t}\r\n\t\tfor (var i = x.digits.length - 1; i >= 0; --i) {\r\n\t\t\tif (x.digits[i] != y.digits[i]) {\r\n\t\t\t\tif (x.isNeg) {\r\n\t\t\t\t\treturn 1 - 2 * Number(x.digits[i] > y.digits[i]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn 1 - 2 * Number(x.digits[i] < y.digits[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0;\r\n\t};\r\n\t\r\n\tRSAUtils.biDivideModulo = function(x, y) {\r\n\t\tvar nb = RSAUtils.biNumBits(x);\r\n\t\tvar tb = RSAUtils.biNumBits(y);\r\n\t\tvar origYIsNeg = y.isNeg;\r\n\t\tvar q, r;\r\n\t\tif (nb < tb) {\r\n\t\t\t// |x| < |y|\r\n\t\t\tif (x.isNeg) {\r\n\t\t\t\tq = RSAUtils.biCopy(bigOne);\r\n\t\t\t\tq.isNeg = !y.isNeg;\r\n\t\t\t\tx.isNeg = false;\r\n\t\t\t\ty.isNeg = false;\r\n\t\t\t\tr = biSubtract(y, x);\r\n\t\t\t\t// Restore signs, 'cause they're references.\r\n\t\t\t\tx.isNeg = true;\r\n\t\t\t\ty.isNeg = origYIsNeg;\r\n\t\t\t} else {\r\n\t\t\t\tq = new BigInt();\r\n\t\t\t\tr = RSAUtils.biCopy(x);\r\n\t\t\t}\r\n\t\t\treturn [q, r];\r\n\t\t}\r\n\t\r\n\t\tq = new BigInt();\r\n\t\tr = x;\r\n\t\r\n\t\t// Normalize Y.\r\n\t\tvar t = Math.ceil(tb / bitsPerDigit) - 1;\r\n\t\tvar lambda = 0;\r\n\t\twhile (y.digits[t] < biHalfRadix) {\r\n\t\t\ty = RSAUtils.biShiftLeft(y, 1);\r\n\t\t\t++lambda;\r\n\t\t\t++tb;\r\n\t\t\tt = Math.ceil(tb / bitsPerDigit) - 1;\r\n\t\t}\r\n\t\t// Shift r over to keep the quotient constant. We'll shift the\r\n\t\t// remainder back at the end.\r\n\t\tr = RSAUtils.biShiftLeft(r, lambda);\r\n\t\tnb += lambda; // Update the bit count for x.\r\n\t\tvar n = Math.ceil(nb / bitsPerDigit) - 1;\r\n\t\r\n\t\tvar b = RSAUtils.biMultiplyByRadixPower(y, n - t);\r\n\t\twhile (RSAUtils.biCompare(r, b) != -1) {\r\n\t\t\t++q.digits[n - t];\r\n\t\t\tr = RSAUtils.biSubtract(r, b);\r\n\t\t}\r\n\t\tfor (var i = n; i > t; --i) {\r\n\t    var ri = (i >= r.digits.length) ? 0 : r.digits[i];\r\n\t    var ri1 = (i - 1 >= r.digits.length) ? 0 : r.digits[i - 1];\r\n\t    var ri2 = (i - 2 >= r.digits.length) ? 0 : r.digits[i - 2];\r\n\t    var yt = (t >= y.digits.length) ? 0 : y.digits[t];\r\n\t    var yt1 = (t - 1 >= y.digits.length) ? 0 : y.digits[t - 1];\r\n\t\t\tif (ri == yt) {\r\n\t\t\t\tq.digits[i - t - 1] = maxDigitVal;\r\n\t\t\t} else {\r\n\t\t\t\tq.digits[i - t - 1] = Math.floor((ri * biRadix + ri1) / yt);\r\n\t\t\t}\r\n\t\r\n\t\t\tvar c1 = q.digits[i - t - 1] * ((yt * biRadix) + yt1);\r\n\t\t\tvar c2 = (ri * biRadixSquared) + ((ri1 * biRadix) + ri2);\r\n\t\t\twhile (c1 > c2) {\r\n\t\t\t\t--q.digits[i - t - 1];\r\n\t\t\t\tc1 = q.digits[i - t - 1] * ((yt * biRadix) | yt1);\r\n\t\t\t\tc2 = (ri * biRadix * biRadix) + ((ri1 * biRadix) + ri2);\r\n\t\t\t}\r\n\t\r\n\t\t\tb = RSAUtils.biMultiplyByRadixPower(y, i - t - 1);\r\n\t\t\tr = RSAUtils.biSubtract(r, RSAUtils.biMultiplyDigit(b, q.digits[i - t - 1]));\r\n\t\t\tif (r.isNeg) {\r\n\t\t\t\tr = RSAUtils.biAdd(r, b);\r\n\t\t\t\t--q.digits[i - t - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\tr = RSAUtils.biShiftRight(r, lambda);\r\n\t\t// Fiddle with the signs and stuff to make sure that 0 <= r < y.\r\n\t\tq.isNeg = x.isNeg != origYIsNeg;\r\n\t\tif (x.isNeg) {\r\n\t\t\tif (origYIsNeg) {\r\n\t\t\t\tq = RSAUtils.biAdd(q, bigOne);\r\n\t\t\t} else {\r\n\t\t\t\tq = RSAUtils.biSubtract(q, bigOne);\r\n\t\t\t}\r\n\t\t\ty = RSAUtils.biShiftRight(y, lambda);\r\n\t\t\tr = RSAUtils.biSubtract(y, r);\r\n\t\t}\r\n\t\t// Check for the unbelievably stupid degenerate case of r == -0.\r\n\t\tif (r.digits[0] == 0 && RSAUtils.biHighIndex(r) == 0) r.isNeg = false;\r\n\t\r\n\t\treturn [q, r];\r\n\t};\r\n\t\r\n\tRSAUtils.biDivide = function(x, y) {\r\n\t\treturn RSAUtils.biDivideModulo(x, y)[0];\r\n\t};\r\n\t\r\n\tRSAUtils.biModulo = function(x, y) {\r\n\t\treturn RSAUtils.biDivideModulo(x, y)[1];\r\n\t};\r\n\t\r\n\tRSAUtils.biMultiplyMod = function(x, y, m) {\r\n\t\treturn RSAUtils.biModulo(RSAUtils.biMultiply(x, y), m);\r\n\t};\r\n\t\r\n\tRSAUtils.biPow = function(x, y) {\r\n\t\tvar result = bigOne;\r\n\t\tvar a = x;\r\n\t\twhile (true) {\r\n\t\t\tif ((y & 1) != 0) result = RSAUtils.biMultiply(result, a);\r\n\t\t\ty >>= 1;\r\n\t\t\tif (y == 0) break;\r\n\t\t\ta = RSAUtils.biMultiply(a, a);\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biPowMod = function(x, y, m) {\r\n\t\tvar result = bigOne;\r\n\t\tvar a = x;\r\n\t\tvar k = y;\r\n\t\twhile (true) {\r\n\t\t\tif ((k.digits[0] & 1) != 0) result = RSAUtils.biMultiplyMod(result, a, m);\r\n\t\t\tk = RSAUtils.biShiftRight(k, 1);\r\n\t\t\tif (k.digits[0] == 0 && RSAUtils.biHighIndex(k) == 0) break;\r\n\t\t\ta = RSAUtils.biMultiplyMod(a, a, m);\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\t\r\n\tBarrettMu = function(m) {\r\n\t\tthis.modulus = RSAUtils.biCopy(m);\r\n\t\tthis.k = RSAUtils.biHighIndex(this.modulus) + 1;\r\n\t\tvar b2k = new BigInt();\r\n\t\tb2k.digits[2 * this.k] = 1; // b2k = b^(2k)\r\n\t\tthis.mu = RSAUtils.biDivide(b2k, this.modulus);\r\n\t\tthis.bkplus1 = new BigInt();\r\n\t\tthis.bkplus1.digits[this.k + 1] = 1; // bkplus1 = b^(k+1)\r\n\t\tthis.modulo = BarrettMu_modulo;\r\n\t\tthis.multiplyMod = BarrettMu_multiplyMod;\r\n\t\tthis.powMod = BarrettMu_powMod;\r\n\t};\r\n\t\r\n\tfunction BarrettMu_modulo(x) {\r\n\t\tvar $dmath = RSAUtils;\r\n\t\tvar q1 = $dmath.biDivideByRadixPower(x, this.k - 1);\r\n\t\tvar q2 = $dmath.biMultiply(q1, this.mu);\r\n\t\tvar q3 = $dmath.biDivideByRadixPower(q2, this.k + 1);\r\n\t\tvar r1 = $dmath.biModuloByRadixPower(x, this.k + 1);\r\n\t\tvar r2term = $dmath.biMultiply(q3, this.modulus);\r\n\t\tvar r2 = $dmath.biModuloByRadixPower(r2term, this.k + 1);\r\n\t\tvar r = $dmath.biSubtract(r1, r2);\r\n\t\tif (r.isNeg) {\r\n\t\t\tr = $dmath.biAdd(r, this.bkplus1);\r\n\t\t}\r\n\t\tvar rgtem = $dmath.biCompare(r, this.modulus) >= 0;\r\n\t\twhile (rgtem) {\r\n\t\t\tr = $dmath.biSubtract(r, this.modulus);\r\n\t\t\trgtem = $dmath.biCompare(r, this.modulus) >= 0;\r\n\t\t}\r\n\t\treturn r;\r\n\t}\r\n\t\r\n\tfunction BarrettMu_multiplyMod(x, y) {\r\n\t\t/*\r\n\t\tx = this.modulo(x);\r\n\t\ty = this.modulo(y);\r\n\t\t*/\r\n\t\tvar xy = RSAUtils.biMultiply(x, y);\r\n\t\treturn this.modulo(xy);\r\n\t}\r\n\t\r\n\tfunction BarrettMu_powMod(x, y) {\r\n\t\tvar result = new BigInt();\r\n\t\tresult.digits[0] = 1;\r\n\t\tvar a = x;\r\n\t\tvar k = y;\r\n\t\twhile (true) {\r\n\t\t\tif ((k.digits[0] & 1) != 0) result = this.multiplyMod(result, a);\r\n\t\t\tk = RSAUtils.biShiftRight(k, 1);\r\n\t\t\tif (k.digits[0] == 0 && RSAUtils.biHighIndex(k) == 0) break;\r\n\t\t\ta = this.multiplyMod(a, a);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\tvar RSAKeyPair = function(encryptionExponent, decryptionExponent, modulus) {\r\n\t\tvar $dmath = RSAUtils;\r\n\t\tthis.e = $dmath.biFromHex(encryptionExponent);\r\n\t\tthis.d = $dmath.biFromHex(decryptionExponent);\r\n\t\tthis.m = $dmath.biFromHex(modulus);\r\n\t\t// We can do two bytes per digit, so\r\n\t\t// chunkSize = 2 * (number of digits in modulus - 1).\r\n\t\t// Since biHighIndex returns the high index, not the number of digits, 1 has\r\n\t\t// already been subtracted.\r\n\t\tthis.chunkSize = 2 * $dmath.biHighIndex(this.m);\r\n\t\tthis.radix = 16;\r\n\t\tthis.barrett = new BarrettMu(this.m);\r\n\t};\r\n\t\r\n\tRSAUtils.getKeyPair = function(encryptionExponent, decryptionExponent, modulus) {\r\n\t\treturn new RSAKeyPair(encryptionExponent, decryptionExponent, modulus);\r\n\t};\r\n\t\r\n\tif(typeof twoDigit === 'undefined') {\r\n\t\ttwoDigit = function(n) {\r\n\t\t\treturn (n < 10 ? \"0\" : \"\") + String(n);\r\n\t\t};\r\n\t}\r\n\t\r\n\t// Altered by Rob Saunders (rob@robsaunders.net). New routine pads the\r\n\t// string after it has been converted to an array. This fixes an\r\n\t// incompatibility with Flash MX's ActionScript.\r\n\tRSAUtils.encryptedString = function(key, s) {\r\n\t\tvar a = [];\r\n\t\tvar sl = s.length;\r\n\t\tvar i = 0;\r\n\t\twhile (i < sl) {\r\n\t\t\ta[i] = s.charCodeAt(i);\r\n\t\t\ti++;\r\n\t\t}\r\n\t\r\n\t\twhile (a.length % key.chunkSize != 0) {\r\n\t\t\ta[i++] = 0;\r\n\t\t}\r\n\t\r\n\t\tvar al = a.length;\r\n\t\tvar result = \"\";\r\n\t\tvar j, k, block;\r\n\t\tfor (i = 0; i < al; i += key.chunkSize) {\r\n\t\t\tblock = new BigInt();\r\n\t\t\tj = 0;\r\n\t\t\tfor (k = i; k < i + key.chunkSize; ++j) {\r\n\t\t\t\tblock.digits[j] = a[k++];\r\n\t\t\t\tblock.digits[j] += a[k++] << 8;\r\n\t\t\t}\r\n\t\t\tvar crypt = key.barrett.powMod(block, key.e);\r\n\t\t\tvar text = key.radix == 16 ? RSAUtils.biToHex(crypt) : RSAUtils.biToString(crypt, key.radix);\r\n\t\t\tresult += text + \" \";\r\n\t\t}\r\n\t\treturn result.substring(0, result.length - 1); // Remove last space.\r\n\t};\r\n\t\r\n\tRSAUtils.decryptedString = function(key, s) {\r\n\t\tvar blocks = s.split(\" \");\r\n\t\tvar result = \"\";\r\n\t\tvar i, j, block;\r\n\t\tfor (i = 0; i < blocks.length; ++i) {\r\n\t\t\tvar bi;\r\n\t\t\tif (key.radix == 16) {\r\n\t\t\t\tbi = RSAUtils.biFromHex(blocks[i]);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbi = RSAUtils.biFromString(blocks[i], key.radix);\r\n\t\t\t}\r\n\t\t\tblock = key.barrett.powMod(bi, key.d);\r\n\t\t\tfor (j = 0; j <= RSAUtils.biHighIndex(block); ++j) {\r\n\t\t\t\tresult += String.fromCharCode(block.digits[j] & 255,\r\n\t\t\t\t                              block.digits[j] >> 8);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Remove trailing null, if any.\r\n\t\tif (result.charCodeAt(result.length - 1) == 0) {\r\n\t\t\tresult = result.substring(0, result.length - 1);\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.setMaxDigits(130);\r\n\t\r\n\tmodule.exports = RSAUtils;\r\n\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** scripts/login.bundle.js\n **/","\r\nvar Utils = require('utils')\r\nrequire('../../common/common.scss')\r\nrequire('./login.scss')\r\n\r\nvar RSAUtils = require('./rsautils')\r\nvar CEIS = {}\r\n\r\n$.post(Utils.URL.RSA_KEY)\r\n .done(function(data) {\r\n  if (data && data.content) {\r\n    CEIS.exponent = data.content.e;\r\n    CEIS.modulus = data.content.n;\r\n  }\r\n })\r\n\r\n$('#toast').on('opened.modal.amui', function() {\r\n  setTimeout(function() {\r\n    $(this).modal('close')\r\n  }.bind(this), 1000)\r\n})\r\n\r\n$('#username').on('change', function() {\r\n  var $username = $(this);\r\n  $username.val($.trim($username.val()).toUpperCase());\r\n})\r\n\r\n$('#validateCodeDiv').on('click', 'a', function() {\r\n  var img = $(this).prev()[0]\r\n  img.src = Utils.URL.VALIDATA_IMG + '?' + Math.random()\r\n})\r\n\r\nvar $loginBtn = $('#loginBtn')\r\n\r\nfunction effectStart() {\r\n  $.AMUI.progress.set(0.8)\r\n  $loginBtn.button('loading')\r\n}\r\n\r\nfunction effectDone() {\r\n  $.AMUI.progress.done()\r\n  $loginBtn.button('reset')\r\n}\r\n\r\n$('#loginForm').submit(function(ev) {\r\n  ev.preventDefault()\r\n\r\n  var $username = $('#username')\r\n  var $password = $('#password')\r\n  var $validate = $('#validateCode')\r\n  var pwd_str = $.trim($password.val()),\r\n      act_str = $.trim($username.val()),\r\n      vali_str = $.trim($validate.val())\r\n\r\n  if (act_str === '') {\r\n    $('#toast-cnt').html('请填写用户名')\r\n    $('#toast').modal('open')\r\n  }\r\n  else if (pwd_str === '') {\r\n    $('#toast-cnt').html('请填写密码')\r\n    $('#toast').modal('open')\r\n  }\r\n  else if ($('#validateCodeDiv').is(':visible') && vali_str === '') {\r\n    $('#toast-cnt').html('请填写验证码')\r\n    $('#toast').modal('open')\r\n  }\r\n  else {\r\n    effectStart()\r\n\r\n    var $loginForm = $(this)\r\n    if (CEIS.exponent && CEIS.modulus) {\r\n      var key = RSAUtils.getKeyPair(CEIS.exponent, '', CEIS.modulus);\r\n      var encryptedPwd = RSAUtils.encryptedString(key, pwd_str);\r\n      $password.val(encryptedPwd);\r\n    }\r\n\r\n    $.post(Utils.URL.LOGIN, $loginForm.serializeArray())\r\n     .done(function(data) {\r\n       if (data && data.status === 'success') {\r\n         CEIS.sessionid = data.content.sessionid;\r\n         CEIS.firstLogin = data.content.firstLogin;\r\n         Utils.storage.set('ceis', CEIS.sessionid)\r\n         if (CEIS.firstLogin) {\r\n           $('#toast-cnt').html('首次登陆或密码过期，请修改密码！')\r\n           $('#toast').modal('open')\r\n           Utils.forward('./modifypwd.html')\r\n         }\r\n         else {\r\n           $('#toast-cnt').html('登录成功！')\r\n           $('#toast').modal('open')\r\n           Utils.forward('./index.html')\r\n         }\r\n       }\r\n       else {\r\n         $password.val('')\r\n         $('#toast-cnt').html(data.msg)\r\n         $('#toast').modal('open')\r\n         effectDone()\r\n\r\n         if (data.content && data.content.shiroLoginFailure == 'org.apache.shiro.authc.AuthenticationException'){\r\n           $('#validateCodeDiv').show()\r\n         }\r\n         $('#validateCodeDiv a').click()\r\n       }\r\n     })\r\n     .always(function(data) {\r\n       effectDone()\r\n     })\r\n\r\n    // setTimeout(function() {\r\n    //   $.AMUI.progress.done()\r\n    //   document.location.href = 'index.html'\r\n    // }, 1500)\r\n  }\r\n\r\n})\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app/components/login/login.js\n ** module id = 0\n ** module chunks = 2\n **/","/*\r\n * RSA, a suite of routines for performing RSA public-key computations in JavaScript.\r\n * Copyright 1998-2005 David Shapiro.\r\n * Dave Shapiro\r\n * dave@ohdave.com\r\n * changed by Fuchun, 2010-05-06\r\n * fcrpg2005@gmail.com\r\n */\r\n\r\nvar RSAUtils = {};\r\n\r\nvar biRadixBase = 2;\r\nvar biRadixBits = 16;\r\nvar bitsPerDigit = biRadixBits;\r\nvar biRadix = 1 << 16; // = 2^16 = 65536\r\nvar biHalfRadix = biRadix >>> 1;\r\nvar biRadixSquared = biRadix * biRadix;\r\nvar maxDigitVal = biRadix - 1;\r\nvar maxInteger = 9999999999999998;\r\n\r\n//maxDigits:\r\n//Change this to accommodate your largest number size. Use setMaxDigits()\r\n//to change it!\r\n//\r\n//In general, if you're working with numbers of size N bits, you'll need 2*N\r\n//bits of storage. Each digit holds 16 bits. So, a 1024-bit key will need\r\n//\r\n//1024 * 2 / 16 = 128 digits of storage.\r\n//\r\nvar maxDigits;\r\nvar ZERO_ARRAY;\r\nvar bigZero, bigOne;\r\n\r\nvar BigInt = BigInt = function(flag) {\r\n\tif (typeof flag == \"boolean\" && flag == true) {\r\n\t\tthis.digits = null;\r\n\t} else {\r\n\t\tthis.digits = ZERO_ARRAY.slice(0);\r\n\t}\r\n\tthis.isNeg = false;\r\n};\r\n\r\nRSAUtils.setMaxDigits = function(value) {\r\n\tmaxDigits = value;\r\n\tZERO_ARRAY = new Array(maxDigits);\r\n\tfor (var iza = 0; iza < ZERO_ARRAY.length; iza++) ZERO_ARRAY[iza] = 0;\r\n\tbigZero = new BigInt();\r\n\tbigOne = new BigInt();\r\n\tbigOne.digits[0] = 1;\r\n};\r\nRSAUtils.setMaxDigits(20);\r\n\r\n//The maximum number of digits in base 10 you can convert to an\r\n//integer without JavaScript throwing up on you.\r\nvar dpl10 = 15;\r\n\r\nRSAUtils.biFromNumber = function(i) {\r\n\tvar result = new BigInt();\r\n\tresult.isNeg = i < 0;\r\n\ti = Math.abs(i);\r\n\tvar j = 0;\r\n\twhile (i > 0) {\r\n\t\tresult.digits[j++] = i & maxDigitVal;\r\n\t\ti = Math.floor(i / biRadix);\r\n\t}\r\n\treturn result;\r\n};\r\n\r\n//lr10 = 10 ^ dpl10\r\nvar lr10 = RSAUtils.biFromNumber(1000000000000000);\r\n\r\nRSAUtils.biFromDecimal = function(s) {\r\n\tvar isNeg = s.charAt(0) == '-';\r\n\tvar i = isNeg ? 1 : 0;\r\n\tvar result;\r\n\t// Skip leading zeros.\r\n\twhile (i < s.length && s.charAt(i) == '0') ++i;\r\n\tif (i == s.length) {\r\n\t\tresult = new BigInt();\r\n\t}\r\n\telse {\r\n\t\tvar digitCount = s.length - i;\r\n\t\tvar fgl = digitCount % dpl10;\r\n\t\tif (fgl == 0) fgl = dpl10;\r\n\t\tresult = RSAUtils.biFromNumber(Number(s.substr(i, fgl)));\r\n\t\ti += fgl;\r\n\t\twhile (i < s.length) {\r\n\t\t\tresult = RSAUtils.biAdd(RSAUtils.biMultiply(result, lr10),\r\n\t\t\t\t\tRSAUtils.biFromNumber(Number(s.substr(i, dpl10))));\r\n\t\t\ti += dpl10;\r\n\t\t}\r\n\t\tresult.isNeg = isNeg;\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biCopy = function(bi) {\r\n\tvar result = new BigInt(true);\r\n\tresult.digits = bi.digits.slice(0);\r\n\tresult.isNeg = bi.isNeg;\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.reverseStr = function(s) {\r\n\tvar result = \"\";\r\n\tfor (var i = s.length - 1; i > -1; --i) {\r\n\t\tresult += s.charAt(i);\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nvar hexatrigesimalToChar = [\r\n\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\r\n\t'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\r\n\t'u', 'v', 'w', 'x', 'y', 'z'\r\n];\r\n\r\nRSAUtils.biToString = function(x, radix) { // 2 <= radix <= 36\r\n\tvar b = new BigInt();\r\n\tb.digits[0] = radix;\r\n\tvar qr = RSAUtils.biDivideModulo(x, b);\r\n\tvar result = hexatrigesimalToChar[qr[1].digits[0]];\r\n\twhile (RSAUtils.biCompare(qr[0], bigZero) == 1) {\r\n\t\tqr = RSAUtils.biDivideModulo(qr[0], b);\r\n\t\tdigit = qr[1].digits[0];\r\n\t\tresult += hexatrigesimalToChar[qr[1].digits[0]];\r\n\t}\r\n\treturn (x.isNeg ? \"-\" : \"\") + RSAUtils.reverseStr(result);\r\n};\r\n\r\nRSAUtils.biToDecimal = function(x) {\r\n\tvar b = new BigInt();\r\n\tb.digits[0] = 10;\r\n\tvar qr = RSAUtils.biDivideModulo(x, b);\r\n\tvar result = String(qr[1].digits[0]);\r\n\twhile (RSAUtils.biCompare(qr[0], bigZero) == 1) {\r\n\t\tqr = RSAUtils.biDivideModulo(qr[0], b);\r\n\t\tresult += String(qr[1].digits[0]);\r\n\t}\r\n\treturn (x.isNeg ? \"-\" : \"\") + RSAUtils.reverseStr(result);\r\n};\r\n\r\nvar hexToChar = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n        'a', 'b', 'c', 'd', 'e', 'f'];\r\n\r\nRSAUtils.digitToHex = function(n) {\r\n\tvar mask = 0xf;\r\n\tvar result = \"\";\r\n\tfor (i = 0; i < 4; ++i) {\r\n\t\tresult += hexToChar[n & mask];\r\n\t\tn >>>= 4;\r\n\t}\r\n\treturn RSAUtils.reverseStr(result);\r\n};\r\n\r\nRSAUtils.biToHex = function(x) {\r\n\tvar result = \"\";\r\n\tvar n = RSAUtils.biHighIndex(x);\r\n\tfor (var i = RSAUtils.biHighIndex(x); i > -1; --i) {\r\n\t\tresult += RSAUtils.digitToHex(x.digits[i]);\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.charToHex = function(c) {\r\n\tvar ZERO = 48;\r\n\tvar NINE = ZERO + 9;\r\n\tvar littleA = 97;\r\n\tvar littleZ = littleA + 25;\r\n\tvar bigA = 65;\r\n\tvar bigZ = 65 + 25;\r\n\tvar result;\r\n\r\n\tif (c >= ZERO && c <= NINE) {\r\n\t\tresult = c - ZERO;\r\n\t} else if (c >= bigA && c <= bigZ) {\r\n\t\tresult = 10 + c - bigA;\r\n\t} else if (c >= littleA && c <= littleZ) {\r\n\t\tresult = 10 + c - littleA;\r\n\t} else {\r\n\t\tresult = 0;\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.hexToDigit = function(s) {\r\n\tvar result = 0;\r\n\tvar sl = Math.min(s.length, 4);\r\n\tfor (var i = 0; i < sl; ++i) {\r\n\t\tresult <<= 4;\r\n\t\tresult |= RSAUtils.charToHex(s.charCodeAt(i));\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biFromHex = function(s) {\r\n\tvar result = new BigInt();\r\n\tvar sl = s.length;\r\n\tfor (var i = sl, j = 0; i > 0; i -= 4, ++j) {\r\n\t\tresult.digits[j] = RSAUtils.hexToDigit(s.substr(Math.max(i - 4, 0), Math.min(i, 4)));\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biFromString = function(s, radix) {\r\n\tvar isNeg = s.charAt(0) == '-';\r\n\tvar istop = isNeg ? 1 : 0;\r\n\tvar result = new BigInt();\r\n\tvar place = new BigInt();\r\n\tplace.digits[0] = 1; // radix^0\r\n\tfor (var i = s.length - 1; i >= istop; i--) {\r\n\t\tvar c = s.charCodeAt(i);\r\n\t\tvar digit = RSAUtils.charToHex(c);\r\n\t\tvar biDigit = RSAUtils.biMultiplyDigit(place, digit);\r\n\t\tresult = RSAUtils.biAdd(result, biDigit);\r\n\t\tplace = RSAUtils.biMultiplyDigit(place, radix);\r\n\t}\r\n\tresult.isNeg = isNeg;\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biDump = function(b) {\r\n\treturn (b.isNeg ? \"-\" : \"\") + b.digits.join(\" \");\r\n};\r\n\r\nRSAUtils.biAdd = function(x, y) {\r\n\tvar result;\r\n\r\n\tif (x.isNeg != y.isNeg) {\r\n\t\ty.isNeg = !y.isNeg;\r\n\t\tresult = RSAUtils.biSubtract(x, y);\r\n\t\ty.isNeg = !y.isNeg;\r\n\t}\r\n\telse {\r\n\t\tresult = new BigInt();\r\n\t\tvar c = 0;\r\n\t\tvar n;\r\n\t\tfor (var i = 0; i < x.digits.length; ++i) {\r\n\t\t\tn = x.digits[i] + y.digits[i] + c;\r\n\t\t\tresult.digits[i] = n % biRadix;\r\n\t\t\tc = Number(n >= biRadix);\r\n\t\t}\r\n\t\tresult.isNeg = x.isNeg;\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biSubtract = function(x, y) {\r\n\tvar result;\r\n\tif (x.isNeg != y.isNeg) {\r\n\t\ty.isNeg = !y.isNeg;\r\n\t\tresult = RSAUtils.biAdd(x, y);\r\n\t\ty.isNeg = !y.isNeg;\r\n\t} else {\r\n\t\tresult = new BigInt();\r\n\t\tvar n, c;\r\n\t\tc = 0;\r\n\t\tfor (var i = 0; i < x.digits.length; ++i) {\r\n\t\t\tn = x.digits[i] - y.digits[i] + c;\r\n\t\t\tresult.digits[i] = n % biRadix;\r\n\t\t\t// Stupid non-conforming modulus operation.\r\n\t\t\tif (result.digits[i] < 0) result.digits[i] += biRadix;\r\n\t\t\tc = 0 - Number(n < 0);\r\n\t\t}\r\n\t\t// Fix up the negative sign, if any.\r\n\t\tif (c == -1) {\r\n\t\t\tc = 0;\r\n\t\t\tfor (var i = 0; i < x.digits.length; ++i) {\r\n\t\t\t\tn = 0 - result.digits[i] + c;\r\n\t\t\t\tresult.digits[i] = n % biRadix;\r\n\t\t\t\t// Stupid non-conforming modulus operation.\r\n\t\t\t\tif (result.digits[i] < 0) result.digits[i] += biRadix;\r\n\t\t\t\tc = 0 - Number(n < 0);\r\n\t\t\t}\r\n\t\t\t// Result is opposite sign of arguments.\r\n\t\t\tresult.isNeg = !x.isNeg;\r\n\t\t} else {\r\n\t\t\t// Result is same sign.\r\n\t\t\tresult.isNeg = x.isNeg;\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biHighIndex = function(x) {\r\n\tvar result = x.digits.length - 1;\r\n\twhile (result > 0 && x.digits[result] == 0) --result;\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biNumBits = function(x) {\r\n\tvar n = RSAUtils.biHighIndex(x);\r\n\tvar d = x.digits[n];\r\n\tvar m = (n + 1) * bitsPerDigit;\r\n\tvar result;\r\n\tfor (result = m; result > m - bitsPerDigit; --result) {\r\n\t\tif ((d & 0x8000) != 0) break;\r\n\t\td <<= 1;\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biMultiply = function(x, y) {\r\n\tvar result = new BigInt();\r\n\tvar c;\r\n\tvar n = RSAUtils.biHighIndex(x);\r\n\tvar t = RSAUtils.biHighIndex(y);\r\n\tvar u, uv, k;\r\n\r\n\tfor (var i = 0; i <= t; ++i) {\r\n\t\tc = 0;\r\n\t\tk = i;\r\n\t\tfor (j = 0; j <= n; ++j, ++k) {\r\n\t\t\tuv = result.digits[k] + x.digits[j] * y.digits[i] + c;\r\n\t\t\tresult.digits[k] = uv & maxDigitVal;\r\n\t\t\tc = uv >>> biRadixBits;\r\n\t\t\t//c = Math.floor(uv / biRadix);\r\n\t\t}\r\n\t\tresult.digits[i + n + 1] = c;\r\n\t}\r\n\t// Someone give me a logical xor, please.\r\n\tresult.isNeg = x.isNeg != y.isNeg;\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biMultiplyDigit = function(x, y) {\r\n\tvar n, c, uv;\r\n\r\n\tresult = new BigInt();\r\n\tn = RSAUtils.biHighIndex(x);\r\n\tc = 0;\r\n\tfor (var j = 0; j <= n; ++j) {\r\n\t\tuv = result.digits[j] + x.digits[j] * y + c;\r\n\t\tresult.digits[j] = uv & maxDigitVal;\r\n\t\tc = uv >>> biRadixBits;\r\n\t\t//c = Math.floor(uv / biRadix);\r\n\t}\r\n\tresult.digits[1 + n] = c;\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.arrayCopy = function(src, srcStart, dest, destStart, n) {\r\n\tvar m = Math.min(srcStart + n, src.length);\r\n\tfor (var i = srcStart, j = destStart; i < m; ++i, ++j) {\r\n\t\tdest[j] = src[i];\r\n\t}\r\n};\r\n\r\nvar highBitMasks = [0x0000, 0x8000, 0xC000, 0xE000, 0xF000, 0xF800,\r\n        0xFC00, 0xFE00, 0xFF00, 0xFF80, 0xFFC0, 0xFFE0,\r\n        0xFFF0, 0xFFF8, 0xFFFC, 0xFFFE, 0xFFFF];\r\n\r\nRSAUtils.biShiftLeft = function(x, n) {\r\n\tvar digitCount = Math.floor(n / bitsPerDigit);\r\n\tvar result = new BigInt();\r\n\tRSAUtils.arrayCopy(x.digits, 0, result.digits, digitCount,\r\n\t          result.digits.length - digitCount);\r\n\tvar bits = n % bitsPerDigit;\r\n\tvar rightBits = bitsPerDigit - bits;\r\n\tfor (var i = result.digits.length - 1, i1 = i - 1; i > 0; --i, --i1) {\r\n\t\tresult.digits[i] = ((result.digits[i] << bits) & maxDigitVal) |\r\n\t\t                   ((result.digits[i1] & highBitMasks[bits]) >>>\r\n\t\t                    (rightBits));\r\n\t}\r\n\tresult.digits[0] = ((result.digits[i] << bits) & maxDigitVal);\r\n\tresult.isNeg = x.isNeg;\r\n\treturn result;\r\n};\r\n\r\nvar lowBitMasks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F,\r\n        0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF,\r\n        0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];\r\n\r\nRSAUtils.biShiftRight = function(x, n) {\r\n\tvar digitCount = Math.floor(n / bitsPerDigit);\r\n\tvar result = new BigInt();\r\n\tRSAUtils.arrayCopy(x.digits, digitCount, result.digits, 0,\r\n\t          x.digits.length - digitCount);\r\n\tvar bits = n % bitsPerDigit;\r\n\tvar leftBits = bitsPerDigit - bits;\r\n\tfor (var i = 0, i1 = i + 1; i < result.digits.length - 1; ++i, ++i1) {\r\n\t\tresult.digits[i] = (result.digits[i] >>> bits) |\r\n\t\t                   ((result.digits[i1] & lowBitMasks[bits]) << leftBits);\r\n\t}\r\n\tresult.digits[result.digits.length - 1] >>>= bits;\r\n\tresult.isNeg = x.isNeg;\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biMultiplyByRadixPower = function(x, n) {\r\n\tvar result = new BigInt();\r\n\tRSAUtils.arrayCopy(x.digits, 0, result.digits, n, result.digits.length - n);\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biDivideByRadixPower = function(x, n) {\r\n\tvar result = new BigInt();\r\n\tRSAUtils.arrayCopy(x.digits, n, result.digits, 0, result.digits.length - n);\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biModuloByRadixPower = function(x, n) {\r\n\tvar result = new BigInt();\r\n\tRSAUtils.arrayCopy(x.digits, 0, result.digits, 0, n);\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biCompare = function(x, y) {\r\n\tif (x.isNeg != y.isNeg) {\r\n\t\treturn 1 - 2 * Number(x.isNeg);\r\n\t}\r\n\tfor (var i = x.digits.length - 1; i >= 0; --i) {\r\n\t\tif (x.digits[i] != y.digits[i]) {\r\n\t\t\tif (x.isNeg) {\r\n\t\t\t\treturn 1 - 2 * Number(x.digits[i] > y.digits[i]);\r\n\t\t\t} else {\r\n\t\t\t\treturn 1 - 2 * Number(x.digits[i] < y.digits[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n};\r\n\r\nRSAUtils.biDivideModulo = function(x, y) {\r\n\tvar nb = RSAUtils.biNumBits(x);\r\n\tvar tb = RSAUtils.biNumBits(y);\r\n\tvar origYIsNeg = y.isNeg;\r\n\tvar q, r;\r\n\tif (nb < tb) {\r\n\t\t// |x| < |y|\r\n\t\tif (x.isNeg) {\r\n\t\t\tq = RSAUtils.biCopy(bigOne);\r\n\t\t\tq.isNeg = !y.isNeg;\r\n\t\t\tx.isNeg = false;\r\n\t\t\ty.isNeg = false;\r\n\t\t\tr = biSubtract(y, x);\r\n\t\t\t// Restore signs, 'cause they're references.\r\n\t\t\tx.isNeg = true;\r\n\t\t\ty.isNeg = origYIsNeg;\r\n\t\t} else {\r\n\t\t\tq = new BigInt();\r\n\t\t\tr = RSAUtils.biCopy(x);\r\n\t\t}\r\n\t\treturn [q, r];\r\n\t}\r\n\r\n\tq = new BigInt();\r\n\tr = x;\r\n\r\n\t// Normalize Y.\r\n\tvar t = Math.ceil(tb / bitsPerDigit) - 1;\r\n\tvar lambda = 0;\r\n\twhile (y.digits[t] < biHalfRadix) {\r\n\t\ty = RSAUtils.biShiftLeft(y, 1);\r\n\t\t++lambda;\r\n\t\t++tb;\r\n\t\tt = Math.ceil(tb / bitsPerDigit) - 1;\r\n\t}\r\n\t// Shift r over to keep the quotient constant. We'll shift the\r\n\t// remainder back at the end.\r\n\tr = RSAUtils.biShiftLeft(r, lambda);\r\n\tnb += lambda; // Update the bit count for x.\r\n\tvar n = Math.ceil(nb / bitsPerDigit) - 1;\r\n\r\n\tvar b = RSAUtils.biMultiplyByRadixPower(y, n - t);\r\n\twhile (RSAUtils.biCompare(r, b) != -1) {\r\n\t\t++q.digits[n - t];\r\n\t\tr = RSAUtils.biSubtract(r, b);\r\n\t}\r\n\tfor (var i = n; i > t; --i) {\r\n    var ri = (i >= r.digits.length) ? 0 : r.digits[i];\r\n    var ri1 = (i - 1 >= r.digits.length) ? 0 : r.digits[i - 1];\r\n    var ri2 = (i - 2 >= r.digits.length) ? 0 : r.digits[i - 2];\r\n    var yt = (t >= y.digits.length) ? 0 : y.digits[t];\r\n    var yt1 = (t - 1 >= y.digits.length) ? 0 : y.digits[t - 1];\r\n\t\tif (ri == yt) {\r\n\t\t\tq.digits[i - t - 1] = maxDigitVal;\r\n\t\t} else {\r\n\t\t\tq.digits[i - t - 1] = Math.floor((ri * biRadix + ri1) / yt);\r\n\t\t}\r\n\r\n\t\tvar c1 = q.digits[i - t - 1] * ((yt * biRadix) + yt1);\r\n\t\tvar c2 = (ri * biRadixSquared) + ((ri1 * biRadix) + ri2);\r\n\t\twhile (c1 > c2) {\r\n\t\t\t--q.digits[i - t - 1];\r\n\t\t\tc1 = q.digits[i - t - 1] * ((yt * biRadix) | yt1);\r\n\t\t\tc2 = (ri * biRadix * biRadix) + ((ri1 * biRadix) + ri2);\r\n\t\t}\r\n\r\n\t\tb = RSAUtils.biMultiplyByRadixPower(y, i - t - 1);\r\n\t\tr = RSAUtils.biSubtract(r, RSAUtils.biMultiplyDigit(b, q.digits[i - t - 1]));\r\n\t\tif (r.isNeg) {\r\n\t\t\tr = RSAUtils.biAdd(r, b);\r\n\t\t\t--q.digits[i - t - 1];\r\n\t\t}\r\n\t}\r\n\tr = RSAUtils.biShiftRight(r, lambda);\r\n\t// Fiddle with the signs and stuff to make sure that 0 <= r < y.\r\n\tq.isNeg = x.isNeg != origYIsNeg;\r\n\tif (x.isNeg) {\r\n\t\tif (origYIsNeg) {\r\n\t\t\tq = RSAUtils.biAdd(q, bigOne);\r\n\t\t} else {\r\n\t\t\tq = RSAUtils.biSubtract(q, bigOne);\r\n\t\t}\r\n\t\ty = RSAUtils.biShiftRight(y, lambda);\r\n\t\tr = RSAUtils.biSubtract(y, r);\r\n\t}\r\n\t// Check for the unbelievably stupid degenerate case of r == -0.\r\n\tif (r.digits[0] == 0 && RSAUtils.biHighIndex(r) == 0) r.isNeg = false;\r\n\r\n\treturn [q, r];\r\n};\r\n\r\nRSAUtils.biDivide = function(x, y) {\r\n\treturn RSAUtils.biDivideModulo(x, y)[0];\r\n};\r\n\r\nRSAUtils.biModulo = function(x, y) {\r\n\treturn RSAUtils.biDivideModulo(x, y)[1];\r\n};\r\n\r\nRSAUtils.biMultiplyMod = function(x, y, m) {\r\n\treturn RSAUtils.biModulo(RSAUtils.biMultiply(x, y), m);\r\n};\r\n\r\nRSAUtils.biPow = function(x, y) {\r\n\tvar result = bigOne;\r\n\tvar a = x;\r\n\twhile (true) {\r\n\t\tif ((y & 1) != 0) result = RSAUtils.biMultiply(result, a);\r\n\t\ty >>= 1;\r\n\t\tif (y == 0) break;\r\n\t\ta = RSAUtils.biMultiply(a, a);\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biPowMod = function(x, y, m) {\r\n\tvar result = bigOne;\r\n\tvar a = x;\r\n\tvar k = y;\r\n\twhile (true) {\r\n\t\tif ((k.digits[0] & 1) != 0) result = RSAUtils.biMultiplyMod(result, a, m);\r\n\t\tk = RSAUtils.biShiftRight(k, 1);\r\n\t\tif (k.digits[0] == 0 && RSAUtils.biHighIndex(k) == 0) break;\r\n\t\ta = RSAUtils.biMultiplyMod(a, a, m);\r\n\t}\r\n\treturn result;\r\n};\r\n\r\n\r\nBarrettMu = function(m) {\r\n\tthis.modulus = RSAUtils.biCopy(m);\r\n\tthis.k = RSAUtils.biHighIndex(this.modulus) + 1;\r\n\tvar b2k = new BigInt();\r\n\tb2k.digits[2 * this.k] = 1; // b2k = b^(2k)\r\n\tthis.mu = RSAUtils.biDivide(b2k, this.modulus);\r\n\tthis.bkplus1 = new BigInt();\r\n\tthis.bkplus1.digits[this.k + 1] = 1; // bkplus1 = b^(k+1)\r\n\tthis.modulo = BarrettMu_modulo;\r\n\tthis.multiplyMod = BarrettMu_multiplyMod;\r\n\tthis.powMod = BarrettMu_powMod;\r\n};\r\n\r\nfunction BarrettMu_modulo(x) {\r\n\tvar $dmath = RSAUtils;\r\n\tvar q1 = $dmath.biDivideByRadixPower(x, this.k - 1);\r\n\tvar q2 = $dmath.biMultiply(q1, this.mu);\r\n\tvar q3 = $dmath.biDivideByRadixPower(q2, this.k + 1);\r\n\tvar r1 = $dmath.biModuloByRadixPower(x, this.k + 1);\r\n\tvar r2term = $dmath.biMultiply(q3, this.modulus);\r\n\tvar r2 = $dmath.biModuloByRadixPower(r2term, this.k + 1);\r\n\tvar r = $dmath.biSubtract(r1, r2);\r\n\tif (r.isNeg) {\r\n\t\tr = $dmath.biAdd(r, this.bkplus1);\r\n\t}\r\n\tvar rgtem = $dmath.biCompare(r, this.modulus) >= 0;\r\n\twhile (rgtem) {\r\n\t\tr = $dmath.biSubtract(r, this.modulus);\r\n\t\trgtem = $dmath.biCompare(r, this.modulus) >= 0;\r\n\t}\r\n\treturn r;\r\n}\r\n\r\nfunction BarrettMu_multiplyMod(x, y) {\r\n\t/*\r\n\tx = this.modulo(x);\r\n\ty = this.modulo(y);\r\n\t*/\r\n\tvar xy = RSAUtils.biMultiply(x, y);\r\n\treturn this.modulo(xy);\r\n}\r\n\r\nfunction BarrettMu_powMod(x, y) {\r\n\tvar result = new BigInt();\r\n\tresult.digits[0] = 1;\r\n\tvar a = x;\r\n\tvar k = y;\r\n\twhile (true) {\r\n\t\tif ((k.digits[0] & 1) != 0) result = this.multiplyMod(result, a);\r\n\t\tk = RSAUtils.biShiftRight(k, 1);\r\n\t\tif (k.digits[0] == 0 && RSAUtils.biHighIndex(k) == 0) break;\r\n\t\ta = this.multiplyMod(a, a);\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nvar RSAKeyPair = function(encryptionExponent, decryptionExponent, modulus) {\r\n\tvar $dmath = RSAUtils;\r\n\tthis.e = $dmath.biFromHex(encryptionExponent);\r\n\tthis.d = $dmath.biFromHex(decryptionExponent);\r\n\tthis.m = $dmath.biFromHex(modulus);\r\n\t// We can do two bytes per digit, so\r\n\t// chunkSize = 2 * (number of digits in modulus - 1).\r\n\t// Since biHighIndex returns the high index, not the number of digits, 1 has\r\n\t// already been subtracted.\r\n\tthis.chunkSize = 2 * $dmath.biHighIndex(this.m);\r\n\tthis.radix = 16;\r\n\tthis.barrett = new BarrettMu(this.m);\r\n};\r\n\r\nRSAUtils.getKeyPair = function(encryptionExponent, decryptionExponent, modulus) {\r\n\treturn new RSAKeyPair(encryptionExponent, decryptionExponent, modulus);\r\n};\r\n\r\nif(typeof twoDigit === 'undefined') {\r\n\ttwoDigit = function(n) {\r\n\t\treturn (n < 10 ? \"0\" : \"\") + String(n);\r\n\t};\r\n}\r\n\r\n// Altered by Rob Saunders (rob@robsaunders.net). New routine pads the\r\n// string after it has been converted to an array. This fixes an\r\n// incompatibility with Flash MX's ActionScript.\r\nRSAUtils.encryptedString = function(key, s) {\r\n\tvar a = [];\r\n\tvar sl = s.length;\r\n\tvar i = 0;\r\n\twhile (i < sl) {\r\n\t\ta[i] = s.charCodeAt(i);\r\n\t\ti++;\r\n\t}\r\n\r\n\twhile (a.length % key.chunkSize != 0) {\r\n\t\ta[i++] = 0;\r\n\t}\r\n\r\n\tvar al = a.length;\r\n\tvar result = \"\";\r\n\tvar j, k, block;\r\n\tfor (i = 0; i < al; i += key.chunkSize) {\r\n\t\tblock = new BigInt();\r\n\t\tj = 0;\r\n\t\tfor (k = i; k < i + key.chunkSize; ++j) {\r\n\t\t\tblock.digits[j] = a[k++];\r\n\t\t\tblock.digits[j] += a[k++] << 8;\r\n\t\t}\r\n\t\tvar crypt = key.barrett.powMod(block, key.e);\r\n\t\tvar text = key.radix == 16 ? RSAUtils.biToHex(crypt) : RSAUtils.biToString(crypt, key.radix);\r\n\t\tresult += text + \" \";\r\n\t}\r\n\treturn result.substring(0, result.length - 1); // Remove last space.\r\n};\r\n\r\nRSAUtils.decryptedString = function(key, s) {\r\n\tvar blocks = s.split(\" \");\r\n\tvar result = \"\";\r\n\tvar i, j, block;\r\n\tfor (i = 0; i < blocks.length; ++i) {\r\n\t\tvar bi;\r\n\t\tif (key.radix == 16) {\r\n\t\t\tbi = RSAUtils.biFromHex(blocks[i]);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tbi = RSAUtils.biFromString(blocks[i], key.radix);\r\n\t\t}\r\n\t\tblock = key.barrett.powMod(bi, key.d);\r\n\t\tfor (j = 0; j <= RSAUtils.biHighIndex(block); ++j) {\r\n\t\t\tresult += String.fromCharCode(block.digits[j] & 255,\r\n\t\t\t                              block.digits[j] >> 8);\r\n\t\t}\r\n\t}\r\n\t// Remove trailing null, if any.\r\n\tif (result.charCodeAt(result.length - 1) == 0) {\r\n\t\tresult = result.substring(0, result.length - 1);\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.setMaxDigits(130);\r\n\r\nmodule.exports = RSAUtils;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app/components/login/rsautils.js\n ** module id = 18\n ** module chunks = 2\n **/"],"sourceRoot":""}