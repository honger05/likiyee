{"version":3,"sources":["webpack:///scripts/login.bundle.js","webpack:///./src/app/components/login/login.js","webpack:///./src/app/components/login/rsautils.js"],"names":["webpackJsonp",0,"module","exports","__webpack_require__","$","effectStart","AMUI","progress","set","$loginBtn","button","Utils","RSAUtils","CEIS","VALIDATA_IMG_URL","CONTEXT_URL","on","setTimeout","this","modal","bind","$username","val","trim","toUpperCase","img","prev","src","Math","random","submit","ev","preventDefault","$password","$validate","pwd_str","act_str","vali_str","html","is","exponent","modulus","key","getKeyPair","encryptedPwd","encryptedString","done","document","location","href","call",9,13,"BarrettMu_modulo","x","$dmath","q1","biDivideByRadixPower","k","q2","biMultiply","mu","q3","r1","biModuloByRadixPower","r2term","r2","r","biSubtract","isNeg","biAdd","bkplus1","rgtem","biCompare","BarrettMu_multiplyMod","y","xy","modulo","BarrettMu_powMod","result","BigInt","digits","a","multiplyMod","biShiftRight","biHighIndex","maxDigits","ZERO_ARRAY","bigZero","bigOne","biRadixBits","bitsPerDigit","biRadix","biHalfRadix","biRadixSquared","maxDigitVal","flag","slice","setMaxDigits","value","Array","iza","length","dpl10","biFromNumber","i","abs","j","floor","lr10","biFromDecimal","s","charAt","digitCount","fgl","Number","substr","biCopy","bi","reverseStr","hexatrigesimalToChar","biToString","radix","b","qr","biDivideModulo","digit","biToDecimal","String","hexToChar","digitToHex","n","mask","biToHex","charToHex","c","ZERO","NINE","littleA","littleZ","bigA","bigZ","hexToDigit","sl","min","charCodeAt","biFromHex","max","biFromString","istop","place","biDigit","biMultiplyDigit","biDump","join","biNumBits","d","m","uv","t","arrayCopy","srcStart","dest","destStart","highBitMasks","biShiftLeft","bits","rightBits","i1","lowBitMasks","leftBits","biMultiplyByRadixPower","q","nb","tb","origYIsNeg","ceil","lambda","ri","ri1","ri2","yt","yt1","c1","c2","biDivide","biModulo","biMultiplyMod","biPow","biPowMod","BarrettMu","b2k","powMod","RSAKeyPair","encryptionExponent","decryptionExponent","e","chunkSize","barrett","twoDigit","block","al","crypt","text","substring","decryptedString","blocks","split","fromCharCode"],"mappings":"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","file":"./scripts/login.bundle.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function($) {\r\n\tvar Utils = __webpack_require__(3)\r\n\t__webpack_require__(2)\r\n\t__webpack_require__(9)\r\n\t\r\n\tvar RSAUtils = __webpack_require__(13)\r\n\tvar CEIS = {}\r\n\t\r\n\tvar RSA_KEY_URL = Utils.CONTEXT_URL + 'getrsakey.do'\r\n\tvar LOGIN_URL = Utils.CONTEXT_URL + 'login'\r\n\tvar VALIDATA_IMG_URL = 'ceis/servlet/validateCodeServlet'\r\n\t\r\n\t// $.post(RSA_KEY_URL, {}, function(data) {\r\n\t//   if (data && data.content) {\r\n\t//     CEIS.exponent = data.content.e;\r\n\t//     CEIS.modulus = data.content.n;\r\n\t//   }\r\n\t// })\r\n\t\r\n\t$('#toast').on('opened.modal.amui', function() {\r\n\t  setTimeout(function() {\r\n\t    $(this).modal('close')\r\n\t  }.bind(this), 1000)\r\n\t})\r\n\t\r\n\t$('#username').on('change', function() {\r\n\t  var $username = $(this);\r\n\t  $username.val($.trim($username.val()).toUpperCase());\r\n\t})\r\n\t\r\n\t$('#validateCodeDiv').on('click', 'a', function() {\r\n\t  var img = $(this).prev()[0]\r\n\t  img.src = VALIDATA_IMG_URL + '?' + Math.random()\r\n\t})\r\n\t\r\n\tvar $loginBtn = $('#loginBtn')\r\n\t\r\n\tfunction effectStart() {\r\n\t  $.AMUI.progress.set(0.8)\r\n\t  $loginBtn.button('loading')\r\n\t}\r\n\t\r\n\tfunction effectDone() {\r\n\t  $.AMUI.progress.done()\r\n\t  $loginBtn.button('reset')\r\n\t}\r\n\t\r\n\t$('#loginForm').submit(function(ev) {\r\n\t  ev.preventDefault()\r\n\t\r\n\t  var $username = $('#username')\r\n\t  var $password = $('#password')\r\n\t  var $validate = $('#validateCode')\r\n\t  var pwd_str = $.trim($password.val()),\r\n\t      act_str = $.trim($username.val()),\r\n\t      vali_str = $.trim($validate.val())\r\n\t\r\n\t  if (act_str === '') {\r\n\t    $('#toast-cnt').html('请填写用户名')\r\n\t    $('#toast').modal('open')\r\n\t  }\r\n\t  else if (pwd_str === '') {\r\n\t    $('#toast-cnt').html('请填写密码')\r\n\t    $('#toast').modal('open')\r\n\t  }\r\n\t  else if ($('#validateCodeDiv').is(':visible') && vali_str === '') {\r\n\t    $('#toast-cnt').html('请填写验证码')\r\n\t    $('#toast').modal('open')\r\n\t  }\r\n\t  else {\r\n\t    effectStart()\r\n\t\r\n\t    var $loginForm = $(this)\r\n\t    if (CEIS.exponent && CEIS.modulus) {\r\n\t      var key = RSAUtils.getKeyPair(CEIS.exponent, '', CEIS.modulus);\r\n\t      var encryptedPwd = RSAUtils.encryptedString(key, pwd_str);\r\n\t      $password.val(encryptedPwd);\r\n\t    }\r\n\t\r\n\t    // $.post(LOGIN_URL, $loginForm.serializeArray(), function(data) {\r\n\t    //   if (data && data.sessionid) {\r\n\t    //     CEIS.sessionid = data.sessionid;\r\n\t    //     CEIS.firstLogin = data.firstLogin;\r\n\t    //     if (data.firstLogin) {\r\n\t    //       $('#toast-cnt').html('首次登陆或密码过期，请修改密码！')\r\n\t    //       $('#toast').modal('open')\r\n\t    //     }\r\n\t    //     else {\r\n\t    //       $('#toast-cnt').html('登录成功！')\r\n\t    //       $('#toast').modal('open')\r\n\t    //     }\r\n\t    //   }\r\n\t    //   else {\r\n\t    //     $password.val('')\r\n\t    //     $('#toast-cnt').html(data.message)\r\n\t    //     $('#toast').modal('open')\r\n\t    //     effectDone()\r\n\t    //\r\n\t    //     if (data.shiroLoginFailure == 'org.apache.shiro.authc.AuthenticationException'){\r\n\t    //       $('#validateCodeDiv').show();\r\n\t    //     }\r\n\t    //     $('#validateCodeDiv a').click();\r\n\t    //   }\r\n\t    // })\r\n\t\r\n\t    setTimeout(function() {\r\n\t      $.AMUI.progress.done()\r\n\t      document.location.href = 'index.html'\r\n\t    }, 1500)\r\n\t  }\r\n\t\r\n\t})\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n\n/***/ 9:\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n\n/***/ 13:\n/***/ function(module, exports) {\n\n\t/*\r\n\t * RSA, a suite of routines for performing RSA public-key computations in JavaScript.\r\n\t * Copyright 1998-2005 David Shapiro.\r\n\t * Dave Shapiro\r\n\t * dave@ohdave.com\r\n\t * changed by Fuchun, 2010-05-06\r\n\t * fcrpg2005@gmail.com\r\n\t */\r\n\t\r\n\tvar RSAUtils = {};\r\n\t\r\n\tvar biRadixBase = 2;\r\n\tvar biRadixBits = 16;\r\n\tvar bitsPerDigit = biRadixBits;\r\n\tvar biRadix = 1 << 16; // = 2^16 = 65536\r\n\tvar biHalfRadix = biRadix >>> 1;\r\n\tvar biRadixSquared = biRadix * biRadix;\r\n\tvar maxDigitVal = biRadix - 1;\r\n\tvar maxInteger = 9999999999999998;\r\n\t\r\n\t//maxDigits:\r\n\t//Change this to accommodate your largest number size. Use setMaxDigits()\r\n\t//to change it!\r\n\t//\r\n\t//In general, if you're working with numbers of size N bits, you'll need 2*N\r\n\t//bits of storage. Each digit holds 16 bits. So, a 1024-bit key will need\r\n\t//\r\n\t//1024 * 2 / 16 = 128 digits of storage.\r\n\t//\r\n\tvar maxDigits;\r\n\tvar ZERO_ARRAY;\r\n\tvar bigZero, bigOne;\r\n\t\r\n\tvar BigInt = BigInt = function(flag) {\r\n\t\tif (typeof flag == \"boolean\" && flag == true) {\r\n\t\t\tthis.digits = null;\r\n\t\t} else {\r\n\t\t\tthis.digits = ZERO_ARRAY.slice(0);\r\n\t\t}\r\n\t\tthis.isNeg = false;\r\n\t};\r\n\t\r\n\tRSAUtils.setMaxDigits = function(value) {\r\n\t\tmaxDigits = value;\r\n\t\tZERO_ARRAY = new Array(maxDigits);\r\n\t\tfor (var iza = 0; iza < ZERO_ARRAY.length; iza++) ZERO_ARRAY[iza] = 0;\r\n\t\tbigZero = new BigInt();\r\n\t\tbigOne = new BigInt();\r\n\t\tbigOne.digits[0] = 1;\r\n\t};\r\n\tRSAUtils.setMaxDigits(20);\r\n\t\r\n\t//The maximum number of digits in base 10 you can convert to an\r\n\t//integer without JavaScript throwing up on you.\r\n\tvar dpl10 = 15;\r\n\t\r\n\tRSAUtils.biFromNumber = function(i) {\r\n\t\tvar result = new BigInt();\r\n\t\tresult.isNeg = i < 0;\r\n\t\ti = Math.abs(i);\r\n\t\tvar j = 0;\r\n\t\twhile (i > 0) {\r\n\t\t\tresult.digits[j++] = i & maxDigitVal;\r\n\t\t\ti = Math.floor(i / biRadix);\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\t//lr10 = 10 ^ dpl10\r\n\tvar lr10 = RSAUtils.biFromNumber(1000000000000000);\r\n\t\r\n\tRSAUtils.biFromDecimal = function(s) {\r\n\t\tvar isNeg = s.charAt(0) == '-';\r\n\t\tvar i = isNeg ? 1 : 0;\r\n\t\tvar result;\r\n\t\t// Skip leading zeros.\r\n\t\twhile (i < s.length && s.charAt(i) == '0') ++i;\r\n\t\tif (i == s.length) {\r\n\t\t\tresult = new BigInt();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tvar digitCount = s.length - i;\r\n\t\t\tvar fgl = digitCount % dpl10;\r\n\t\t\tif (fgl == 0) fgl = dpl10;\r\n\t\t\tresult = RSAUtils.biFromNumber(Number(s.substr(i, fgl)));\r\n\t\t\ti += fgl;\r\n\t\t\twhile (i < s.length) {\r\n\t\t\t\tresult = RSAUtils.biAdd(RSAUtils.biMultiply(result, lr10),\r\n\t\t\t\t\t\tRSAUtils.biFromNumber(Number(s.substr(i, dpl10))));\r\n\t\t\t\ti += dpl10;\r\n\t\t\t}\r\n\t\t\tresult.isNeg = isNeg;\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biCopy = function(bi) {\r\n\t\tvar result = new BigInt(true);\r\n\t\tresult.digits = bi.digits.slice(0);\r\n\t\tresult.isNeg = bi.isNeg;\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.reverseStr = function(s) {\r\n\t\tvar result = \"\";\r\n\t\tfor (var i = s.length - 1; i > -1; --i) {\r\n\t\t\tresult += s.charAt(i);\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tvar hexatrigesimalToChar = [\r\n\t\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n\t\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\r\n\t\t'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\r\n\t\t'u', 'v', 'w', 'x', 'y', 'z'\r\n\t];\r\n\t\r\n\tRSAUtils.biToString = function(x, radix) { // 2 <= radix <= 36\r\n\t\tvar b = new BigInt();\r\n\t\tb.digits[0] = radix;\r\n\t\tvar qr = RSAUtils.biDivideModulo(x, b);\r\n\t\tvar result = hexatrigesimalToChar[qr[1].digits[0]];\r\n\t\twhile (RSAUtils.biCompare(qr[0], bigZero) == 1) {\r\n\t\t\tqr = RSAUtils.biDivideModulo(qr[0], b);\r\n\t\t\tdigit = qr[1].digits[0];\r\n\t\t\tresult += hexatrigesimalToChar[qr[1].digits[0]];\r\n\t\t}\r\n\t\treturn (x.isNeg ? \"-\" : \"\") + RSAUtils.reverseStr(result);\r\n\t};\r\n\t\r\n\tRSAUtils.biToDecimal = function(x) {\r\n\t\tvar b = new BigInt();\r\n\t\tb.digits[0] = 10;\r\n\t\tvar qr = RSAUtils.biDivideModulo(x, b);\r\n\t\tvar result = String(qr[1].digits[0]);\r\n\t\twhile (RSAUtils.biCompare(qr[0], bigZero) == 1) {\r\n\t\t\tqr = RSAUtils.biDivideModulo(qr[0], b);\r\n\t\t\tresult += String(qr[1].digits[0]);\r\n\t\t}\r\n\t\treturn (x.isNeg ? \"-\" : \"\") + RSAUtils.reverseStr(result);\r\n\t};\r\n\t\r\n\tvar hexToChar = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n\t        'a', 'b', 'c', 'd', 'e', 'f'];\r\n\t\r\n\tRSAUtils.digitToHex = function(n) {\r\n\t\tvar mask = 0xf;\r\n\t\tvar result = \"\";\r\n\t\tfor (i = 0; i < 4; ++i) {\r\n\t\t\tresult += hexToChar[n & mask];\r\n\t\t\tn >>>= 4;\r\n\t\t}\r\n\t\treturn RSAUtils.reverseStr(result);\r\n\t};\r\n\t\r\n\tRSAUtils.biToHex = function(x) {\r\n\t\tvar result = \"\";\r\n\t\tvar n = RSAUtils.biHighIndex(x);\r\n\t\tfor (var i = RSAUtils.biHighIndex(x); i > -1; --i) {\r\n\t\t\tresult += RSAUtils.digitToHex(x.digits[i]);\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.charToHex = function(c) {\r\n\t\tvar ZERO = 48;\r\n\t\tvar NINE = ZERO + 9;\r\n\t\tvar littleA = 97;\r\n\t\tvar littleZ = littleA + 25;\r\n\t\tvar bigA = 65;\r\n\t\tvar bigZ = 65 + 25;\r\n\t\tvar result;\r\n\t\r\n\t\tif (c >= ZERO && c <= NINE) {\r\n\t\t\tresult = c - ZERO;\r\n\t\t} else if (c >= bigA && c <= bigZ) {\r\n\t\t\tresult = 10 + c - bigA;\r\n\t\t} else if (c >= littleA && c <= littleZ) {\r\n\t\t\tresult = 10 + c - littleA;\r\n\t\t} else {\r\n\t\t\tresult = 0;\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.hexToDigit = function(s) {\r\n\t\tvar result = 0;\r\n\t\tvar sl = Math.min(s.length, 4);\r\n\t\tfor (var i = 0; i < sl; ++i) {\r\n\t\t\tresult <<= 4;\r\n\t\t\tresult |= RSAUtils.charToHex(s.charCodeAt(i));\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biFromHex = function(s) {\r\n\t\tvar result = new BigInt();\r\n\t\tvar sl = s.length;\r\n\t\tfor (var i = sl, j = 0; i > 0; i -= 4, ++j) {\r\n\t\t\tresult.digits[j] = RSAUtils.hexToDigit(s.substr(Math.max(i - 4, 0), Math.min(i, 4)));\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biFromString = function(s, radix) {\r\n\t\tvar isNeg = s.charAt(0) == '-';\r\n\t\tvar istop = isNeg ? 1 : 0;\r\n\t\tvar result = new BigInt();\r\n\t\tvar place = new BigInt();\r\n\t\tplace.digits[0] = 1; // radix^0\r\n\t\tfor (var i = s.length - 1; i >= istop; i--) {\r\n\t\t\tvar c = s.charCodeAt(i);\r\n\t\t\tvar digit = RSAUtils.charToHex(c);\r\n\t\t\tvar biDigit = RSAUtils.biMultiplyDigit(place, digit);\r\n\t\t\tresult = RSAUtils.biAdd(result, biDigit);\r\n\t\t\tplace = RSAUtils.biMultiplyDigit(place, radix);\r\n\t\t}\r\n\t\tresult.isNeg = isNeg;\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biDump = function(b) {\r\n\t\treturn (b.isNeg ? \"-\" : \"\") + b.digits.join(\" \");\r\n\t};\r\n\t\r\n\tRSAUtils.biAdd = function(x, y) {\r\n\t\tvar result;\r\n\t\r\n\t\tif (x.isNeg != y.isNeg) {\r\n\t\t\ty.isNeg = !y.isNeg;\r\n\t\t\tresult = RSAUtils.biSubtract(x, y);\r\n\t\t\ty.isNeg = !y.isNeg;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tresult = new BigInt();\r\n\t\t\tvar c = 0;\r\n\t\t\tvar n;\r\n\t\t\tfor (var i = 0; i < x.digits.length; ++i) {\r\n\t\t\t\tn = x.digits[i] + y.digits[i] + c;\r\n\t\t\t\tresult.digits[i] = n % biRadix;\r\n\t\t\t\tc = Number(n >= biRadix);\r\n\t\t\t}\r\n\t\t\tresult.isNeg = x.isNeg;\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biSubtract = function(x, y) {\r\n\t\tvar result;\r\n\t\tif (x.isNeg != y.isNeg) {\r\n\t\t\ty.isNeg = !y.isNeg;\r\n\t\t\tresult = RSAUtils.biAdd(x, y);\r\n\t\t\ty.isNeg = !y.isNeg;\r\n\t\t} else {\r\n\t\t\tresult = new BigInt();\r\n\t\t\tvar n, c;\r\n\t\t\tc = 0;\r\n\t\t\tfor (var i = 0; i < x.digits.length; ++i) {\r\n\t\t\t\tn = x.digits[i] - y.digits[i] + c;\r\n\t\t\t\tresult.digits[i] = n % biRadix;\r\n\t\t\t\t// Stupid non-conforming modulus operation.\r\n\t\t\t\tif (result.digits[i] < 0) result.digits[i] += biRadix;\r\n\t\t\t\tc = 0 - Number(n < 0);\r\n\t\t\t}\r\n\t\t\t// Fix up the negative sign, if any.\r\n\t\t\tif (c == -1) {\r\n\t\t\t\tc = 0;\r\n\t\t\t\tfor (var i = 0; i < x.digits.length; ++i) {\r\n\t\t\t\t\tn = 0 - result.digits[i] + c;\r\n\t\t\t\t\tresult.digits[i] = n % biRadix;\r\n\t\t\t\t\t// Stupid non-conforming modulus operation.\r\n\t\t\t\t\tif (result.digits[i] < 0) result.digits[i] += biRadix;\r\n\t\t\t\t\tc = 0 - Number(n < 0);\r\n\t\t\t\t}\r\n\t\t\t\t// Result is opposite sign of arguments.\r\n\t\t\t\tresult.isNeg = !x.isNeg;\r\n\t\t\t} else {\r\n\t\t\t\t// Result is same sign.\r\n\t\t\t\tresult.isNeg = x.isNeg;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biHighIndex = function(x) {\r\n\t\tvar result = x.digits.length - 1;\r\n\t\twhile (result > 0 && x.digits[result] == 0) --result;\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biNumBits = function(x) {\r\n\t\tvar n = RSAUtils.biHighIndex(x);\r\n\t\tvar d = x.digits[n];\r\n\t\tvar m = (n + 1) * bitsPerDigit;\r\n\t\tvar result;\r\n\t\tfor (result = m; result > m - bitsPerDigit; --result) {\r\n\t\t\tif ((d & 0x8000) != 0) break;\r\n\t\t\td <<= 1;\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biMultiply = function(x, y) {\r\n\t\tvar result = new BigInt();\r\n\t\tvar c;\r\n\t\tvar n = RSAUtils.biHighIndex(x);\r\n\t\tvar t = RSAUtils.biHighIndex(y);\r\n\t\tvar u, uv, k;\r\n\t\r\n\t\tfor (var i = 0; i <= t; ++i) {\r\n\t\t\tc = 0;\r\n\t\t\tk = i;\r\n\t\t\tfor (j = 0; j <= n; ++j, ++k) {\r\n\t\t\t\tuv = result.digits[k] + x.digits[j] * y.digits[i] + c;\r\n\t\t\t\tresult.digits[k] = uv & maxDigitVal;\r\n\t\t\t\tc = uv >>> biRadixBits;\r\n\t\t\t\t//c = Math.floor(uv / biRadix);\r\n\t\t\t}\r\n\t\t\tresult.digits[i + n + 1] = c;\r\n\t\t}\r\n\t\t// Someone give me a logical xor, please.\r\n\t\tresult.isNeg = x.isNeg != y.isNeg;\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biMultiplyDigit = function(x, y) {\r\n\t\tvar n, c, uv;\r\n\t\r\n\t\tresult = new BigInt();\r\n\t\tn = RSAUtils.biHighIndex(x);\r\n\t\tc = 0;\r\n\t\tfor (var j = 0; j <= n; ++j) {\r\n\t\t\tuv = result.digits[j] + x.digits[j] * y + c;\r\n\t\t\tresult.digits[j] = uv & maxDigitVal;\r\n\t\t\tc = uv >>> biRadixBits;\r\n\t\t\t//c = Math.floor(uv / biRadix);\r\n\t\t}\r\n\t\tresult.digits[1 + n] = c;\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.arrayCopy = function(src, srcStart, dest, destStart, n) {\r\n\t\tvar m = Math.min(srcStart + n, src.length);\r\n\t\tfor (var i = srcStart, j = destStart; i < m; ++i, ++j) {\r\n\t\t\tdest[j] = src[i];\r\n\t\t}\r\n\t};\r\n\t\r\n\tvar highBitMasks = [0x0000, 0x8000, 0xC000, 0xE000, 0xF000, 0xF800,\r\n\t        0xFC00, 0xFE00, 0xFF00, 0xFF80, 0xFFC0, 0xFFE0,\r\n\t        0xFFF0, 0xFFF8, 0xFFFC, 0xFFFE, 0xFFFF];\r\n\t\r\n\tRSAUtils.biShiftLeft = function(x, n) {\r\n\t\tvar digitCount = Math.floor(n / bitsPerDigit);\r\n\t\tvar result = new BigInt();\r\n\t\tRSAUtils.arrayCopy(x.digits, 0, result.digits, digitCount,\r\n\t\t          result.digits.length - digitCount);\r\n\t\tvar bits = n % bitsPerDigit;\r\n\t\tvar rightBits = bitsPerDigit - bits;\r\n\t\tfor (var i = result.digits.length - 1, i1 = i - 1; i > 0; --i, --i1) {\r\n\t\t\tresult.digits[i] = ((result.digits[i] << bits) & maxDigitVal) |\r\n\t\t\t                   ((result.digits[i1] & highBitMasks[bits]) >>>\r\n\t\t\t                    (rightBits));\r\n\t\t}\r\n\t\tresult.digits[0] = ((result.digits[i] << bits) & maxDigitVal);\r\n\t\tresult.isNeg = x.isNeg;\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tvar lowBitMasks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F,\r\n\t        0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF,\r\n\t        0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];\r\n\t\r\n\tRSAUtils.biShiftRight = function(x, n) {\r\n\t\tvar digitCount = Math.floor(n / bitsPerDigit);\r\n\t\tvar result = new BigInt();\r\n\t\tRSAUtils.arrayCopy(x.digits, digitCount, result.digits, 0,\r\n\t\t          x.digits.length - digitCount);\r\n\t\tvar bits = n % bitsPerDigit;\r\n\t\tvar leftBits = bitsPerDigit - bits;\r\n\t\tfor (var i = 0, i1 = i + 1; i < result.digits.length - 1; ++i, ++i1) {\r\n\t\t\tresult.digits[i] = (result.digits[i] >>> bits) |\r\n\t\t\t                   ((result.digits[i1] & lowBitMasks[bits]) << leftBits);\r\n\t\t}\r\n\t\tresult.digits[result.digits.length - 1] >>>= bits;\r\n\t\tresult.isNeg = x.isNeg;\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biMultiplyByRadixPower = function(x, n) {\r\n\t\tvar result = new BigInt();\r\n\t\tRSAUtils.arrayCopy(x.digits, 0, result.digits, n, result.digits.length - n);\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biDivideByRadixPower = function(x, n) {\r\n\t\tvar result = new BigInt();\r\n\t\tRSAUtils.arrayCopy(x.digits, n, result.digits, 0, result.digits.length - n);\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biModuloByRadixPower = function(x, n) {\r\n\t\tvar result = new BigInt();\r\n\t\tRSAUtils.arrayCopy(x.digits, 0, result.digits, 0, n);\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biCompare = function(x, y) {\r\n\t\tif (x.isNeg != y.isNeg) {\r\n\t\t\treturn 1 - 2 * Number(x.isNeg);\r\n\t\t}\r\n\t\tfor (var i = x.digits.length - 1; i >= 0; --i) {\r\n\t\t\tif (x.digits[i] != y.digits[i]) {\r\n\t\t\t\tif (x.isNeg) {\r\n\t\t\t\t\treturn 1 - 2 * Number(x.digits[i] > y.digits[i]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn 1 - 2 * Number(x.digits[i] < y.digits[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0;\r\n\t};\r\n\t\r\n\tRSAUtils.biDivideModulo = function(x, y) {\r\n\t\tvar nb = RSAUtils.biNumBits(x);\r\n\t\tvar tb = RSAUtils.biNumBits(y);\r\n\t\tvar origYIsNeg = y.isNeg;\r\n\t\tvar q, r;\r\n\t\tif (nb < tb) {\r\n\t\t\t// |x| < |y|\r\n\t\t\tif (x.isNeg) {\r\n\t\t\t\tq = RSAUtils.biCopy(bigOne);\r\n\t\t\t\tq.isNeg = !y.isNeg;\r\n\t\t\t\tx.isNeg = false;\r\n\t\t\t\ty.isNeg = false;\r\n\t\t\t\tr = biSubtract(y, x);\r\n\t\t\t\t// Restore signs, 'cause they're references.\r\n\t\t\t\tx.isNeg = true;\r\n\t\t\t\ty.isNeg = origYIsNeg;\r\n\t\t\t} else {\r\n\t\t\t\tq = new BigInt();\r\n\t\t\t\tr = RSAUtils.biCopy(x);\r\n\t\t\t}\r\n\t\t\treturn [q, r];\r\n\t\t}\r\n\t\r\n\t\tq = new BigInt();\r\n\t\tr = x;\r\n\t\r\n\t\t// Normalize Y.\r\n\t\tvar t = Math.ceil(tb / bitsPerDigit) - 1;\r\n\t\tvar lambda = 0;\r\n\t\twhile (y.digits[t] < biHalfRadix) {\r\n\t\t\ty = RSAUtils.biShiftLeft(y, 1);\r\n\t\t\t++lambda;\r\n\t\t\t++tb;\r\n\t\t\tt = Math.ceil(tb / bitsPerDigit) - 1;\r\n\t\t}\r\n\t\t// Shift r over to keep the quotient constant. We'll shift the\r\n\t\t// remainder back at the end.\r\n\t\tr = RSAUtils.biShiftLeft(r, lambda);\r\n\t\tnb += lambda; // Update the bit count for x.\r\n\t\tvar n = Math.ceil(nb / bitsPerDigit) - 1;\r\n\t\r\n\t\tvar b = RSAUtils.biMultiplyByRadixPower(y, n - t);\r\n\t\twhile (RSAUtils.biCompare(r, b) != -1) {\r\n\t\t\t++q.digits[n - t];\r\n\t\t\tr = RSAUtils.biSubtract(r, b);\r\n\t\t}\r\n\t\tfor (var i = n; i > t; --i) {\r\n\t    var ri = (i >= r.digits.length) ? 0 : r.digits[i];\r\n\t    var ri1 = (i - 1 >= r.digits.length) ? 0 : r.digits[i - 1];\r\n\t    var ri2 = (i - 2 >= r.digits.length) ? 0 : r.digits[i - 2];\r\n\t    var yt = (t >= y.digits.length) ? 0 : y.digits[t];\r\n\t    var yt1 = (t - 1 >= y.digits.length) ? 0 : y.digits[t - 1];\r\n\t\t\tif (ri == yt) {\r\n\t\t\t\tq.digits[i - t - 1] = maxDigitVal;\r\n\t\t\t} else {\r\n\t\t\t\tq.digits[i - t - 1] = Math.floor((ri * biRadix + ri1) / yt);\r\n\t\t\t}\r\n\t\r\n\t\t\tvar c1 = q.digits[i - t - 1] * ((yt * biRadix) + yt1);\r\n\t\t\tvar c2 = (ri * biRadixSquared) + ((ri1 * biRadix) + ri2);\r\n\t\t\twhile (c1 > c2) {\r\n\t\t\t\t--q.digits[i - t - 1];\r\n\t\t\t\tc1 = q.digits[i - t - 1] * ((yt * biRadix) | yt1);\r\n\t\t\t\tc2 = (ri * biRadix * biRadix) + ((ri1 * biRadix) + ri2);\r\n\t\t\t}\r\n\t\r\n\t\t\tb = RSAUtils.biMultiplyByRadixPower(y, i - t - 1);\r\n\t\t\tr = RSAUtils.biSubtract(r, RSAUtils.biMultiplyDigit(b, q.digits[i - t - 1]));\r\n\t\t\tif (r.isNeg) {\r\n\t\t\t\tr = RSAUtils.biAdd(r, b);\r\n\t\t\t\t--q.digits[i - t - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t\tr = RSAUtils.biShiftRight(r, lambda);\r\n\t\t// Fiddle with the signs and stuff to make sure that 0 <= r < y.\r\n\t\tq.isNeg = x.isNeg != origYIsNeg;\r\n\t\tif (x.isNeg) {\r\n\t\t\tif (origYIsNeg) {\r\n\t\t\t\tq = RSAUtils.biAdd(q, bigOne);\r\n\t\t\t} else {\r\n\t\t\t\tq = RSAUtils.biSubtract(q, bigOne);\r\n\t\t\t}\r\n\t\t\ty = RSAUtils.biShiftRight(y, lambda);\r\n\t\t\tr = RSAUtils.biSubtract(y, r);\r\n\t\t}\r\n\t\t// Check for the unbelievably stupid degenerate case of r == -0.\r\n\t\tif (r.digits[0] == 0 && RSAUtils.biHighIndex(r) == 0) r.isNeg = false;\r\n\t\r\n\t\treturn [q, r];\r\n\t};\r\n\t\r\n\tRSAUtils.biDivide = function(x, y) {\r\n\t\treturn RSAUtils.biDivideModulo(x, y)[0];\r\n\t};\r\n\t\r\n\tRSAUtils.biModulo = function(x, y) {\r\n\t\treturn RSAUtils.biDivideModulo(x, y)[1];\r\n\t};\r\n\t\r\n\tRSAUtils.biMultiplyMod = function(x, y, m) {\r\n\t\treturn RSAUtils.biModulo(RSAUtils.biMultiply(x, y), m);\r\n\t};\r\n\t\r\n\tRSAUtils.biPow = function(x, y) {\r\n\t\tvar result = bigOne;\r\n\t\tvar a = x;\r\n\t\twhile (true) {\r\n\t\t\tif ((y & 1) != 0) result = RSAUtils.biMultiply(result, a);\r\n\t\t\ty >>= 1;\r\n\t\t\tif (y == 0) break;\r\n\t\t\ta = RSAUtils.biMultiply(a, a);\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.biPowMod = function(x, y, m) {\r\n\t\tvar result = bigOne;\r\n\t\tvar a = x;\r\n\t\tvar k = y;\r\n\t\twhile (true) {\r\n\t\t\tif ((k.digits[0] & 1) != 0) result = RSAUtils.biMultiplyMod(result, a, m);\r\n\t\t\tk = RSAUtils.biShiftRight(k, 1);\r\n\t\t\tif (k.digits[0] == 0 && RSAUtils.biHighIndex(k) == 0) break;\r\n\t\t\ta = RSAUtils.biMultiplyMod(a, a, m);\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\t\r\n\tBarrettMu = function(m) {\r\n\t\tthis.modulus = RSAUtils.biCopy(m);\r\n\t\tthis.k = RSAUtils.biHighIndex(this.modulus) + 1;\r\n\t\tvar b2k = new BigInt();\r\n\t\tb2k.digits[2 * this.k] = 1; // b2k = b^(2k)\r\n\t\tthis.mu = RSAUtils.biDivide(b2k, this.modulus);\r\n\t\tthis.bkplus1 = new BigInt();\r\n\t\tthis.bkplus1.digits[this.k + 1] = 1; // bkplus1 = b^(k+1)\r\n\t\tthis.modulo = BarrettMu_modulo;\r\n\t\tthis.multiplyMod = BarrettMu_multiplyMod;\r\n\t\tthis.powMod = BarrettMu_powMod;\r\n\t};\r\n\t\r\n\tfunction BarrettMu_modulo(x) {\r\n\t\tvar $dmath = RSAUtils;\r\n\t\tvar q1 = $dmath.biDivideByRadixPower(x, this.k - 1);\r\n\t\tvar q2 = $dmath.biMultiply(q1, this.mu);\r\n\t\tvar q3 = $dmath.biDivideByRadixPower(q2, this.k + 1);\r\n\t\tvar r1 = $dmath.biModuloByRadixPower(x, this.k + 1);\r\n\t\tvar r2term = $dmath.biMultiply(q3, this.modulus);\r\n\t\tvar r2 = $dmath.biModuloByRadixPower(r2term, this.k + 1);\r\n\t\tvar r = $dmath.biSubtract(r1, r2);\r\n\t\tif (r.isNeg) {\r\n\t\t\tr = $dmath.biAdd(r, this.bkplus1);\r\n\t\t}\r\n\t\tvar rgtem = $dmath.biCompare(r, this.modulus) >= 0;\r\n\t\twhile (rgtem) {\r\n\t\t\tr = $dmath.biSubtract(r, this.modulus);\r\n\t\t\trgtem = $dmath.biCompare(r, this.modulus) >= 0;\r\n\t\t}\r\n\t\treturn r;\r\n\t}\r\n\t\r\n\tfunction BarrettMu_multiplyMod(x, y) {\r\n\t\t/*\r\n\t\tx = this.modulo(x);\r\n\t\ty = this.modulo(y);\r\n\t\t*/\r\n\t\tvar xy = RSAUtils.biMultiply(x, y);\r\n\t\treturn this.modulo(xy);\r\n\t}\r\n\t\r\n\tfunction BarrettMu_powMod(x, y) {\r\n\t\tvar result = new BigInt();\r\n\t\tresult.digits[0] = 1;\r\n\t\tvar a = x;\r\n\t\tvar k = y;\r\n\t\twhile (true) {\r\n\t\t\tif ((k.digits[0] & 1) != 0) result = this.multiplyMod(result, a);\r\n\t\t\tk = RSAUtils.biShiftRight(k, 1);\r\n\t\t\tif (k.digits[0] == 0 && RSAUtils.biHighIndex(k) == 0) break;\r\n\t\t\ta = this.multiplyMod(a, a);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\tvar RSAKeyPair = function(encryptionExponent, decryptionExponent, modulus) {\r\n\t\tvar $dmath = RSAUtils;\r\n\t\tthis.e = $dmath.biFromHex(encryptionExponent);\r\n\t\tthis.d = $dmath.biFromHex(decryptionExponent);\r\n\t\tthis.m = $dmath.biFromHex(modulus);\r\n\t\t// We can do two bytes per digit, so\r\n\t\t// chunkSize = 2 * (number of digits in modulus - 1).\r\n\t\t// Since biHighIndex returns the high index, not the number of digits, 1 has\r\n\t\t// already been subtracted.\r\n\t\tthis.chunkSize = 2 * $dmath.biHighIndex(this.m);\r\n\t\tthis.radix = 16;\r\n\t\tthis.barrett = new BarrettMu(this.m);\r\n\t};\r\n\t\r\n\tRSAUtils.getKeyPair = function(encryptionExponent, decryptionExponent, modulus) {\r\n\t\treturn new RSAKeyPair(encryptionExponent, decryptionExponent, modulus);\r\n\t};\r\n\t\r\n\tif(typeof twoDigit === 'undefined') {\r\n\t\ttwoDigit = function(n) {\r\n\t\t\treturn (n < 10 ? \"0\" : \"\") + String(n);\r\n\t\t};\r\n\t}\r\n\t\r\n\t// Altered by Rob Saunders (rob@robsaunders.net). New routine pads the\r\n\t// string after it has been converted to an array. This fixes an\r\n\t// incompatibility with Flash MX's ActionScript.\r\n\tRSAUtils.encryptedString = function(key, s) {\r\n\t\tvar a = [];\r\n\t\tvar sl = s.length;\r\n\t\tvar i = 0;\r\n\t\twhile (i < sl) {\r\n\t\t\ta[i] = s.charCodeAt(i);\r\n\t\t\ti++;\r\n\t\t}\r\n\t\r\n\t\twhile (a.length % key.chunkSize != 0) {\r\n\t\t\ta[i++] = 0;\r\n\t\t}\r\n\t\r\n\t\tvar al = a.length;\r\n\t\tvar result = \"\";\r\n\t\tvar j, k, block;\r\n\t\tfor (i = 0; i < al; i += key.chunkSize) {\r\n\t\t\tblock = new BigInt();\r\n\t\t\tj = 0;\r\n\t\t\tfor (k = i; k < i + key.chunkSize; ++j) {\r\n\t\t\t\tblock.digits[j] = a[k++];\r\n\t\t\t\tblock.digits[j] += a[k++] << 8;\r\n\t\t\t}\r\n\t\t\tvar crypt = key.barrett.powMod(block, key.e);\r\n\t\t\tvar text = key.radix == 16 ? RSAUtils.biToHex(crypt) : RSAUtils.biToString(crypt, key.radix);\r\n\t\t\tresult += text + \" \";\r\n\t\t}\r\n\t\treturn result.substring(0, result.length - 1); // Remove last space.\r\n\t};\r\n\t\r\n\tRSAUtils.decryptedString = function(key, s) {\r\n\t\tvar blocks = s.split(\" \");\r\n\t\tvar result = \"\";\r\n\t\tvar i, j, block;\r\n\t\tfor (i = 0; i < blocks.length; ++i) {\r\n\t\t\tvar bi;\r\n\t\t\tif (key.radix == 16) {\r\n\t\t\t\tbi = RSAUtils.biFromHex(blocks[i]);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbi = RSAUtils.biFromString(blocks[i], key.radix);\r\n\t\t\t}\r\n\t\t\tblock = key.barrett.powMod(bi, key.d);\r\n\t\t\tfor (j = 0; j <= RSAUtils.biHighIndex(block); ++j) {\r\n\t\t\t\tresult += String.fromCharCode(block.digits[j] & 255,\r\n\t\t\t\t                              block.digits[j] >> 8);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Remove trailing null, if any.\r\n\t\tif (result.charCodeAt(result.length - 1) == 0) {\r\n\t\t\tresult = result.substring(0, result.length - 1);\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tRSAUtils.setMaxDigits(130);\r\n\t\r\n\tmodule.exports = RSAUtils;\r\n\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** scripts/login.bundle.js\n **/","\r\nvar Utils = require('utils')\r\nrequire('../../common/common.scss')\r\nrequire('./login.scss')\r\n\r\nvar RSAUtils = require('./rsautils')\r\nvar CEIS = {}\r\n\r\nvar RSA_KEY_URL = Utils.CONTEXT_URL + 'getrsakey.do'\r\nvar LOGIN_URL = Utils.CONTEXT_URL + 'login'\r\nvar VALIDATA_IMG_URL = 'ceis/servlet/validateCodeServlet'\r\n\r\n// $.post(RSA_KEY_URL, {}, function(data) {\r\n//   if (data && data.content) {\r\n//     CEIS.exponent = data.content.e;\r\n//     CEIS.modulus = data.content.n;\r\n//   }\r\n// })\r\n\r\n$('#toast').on('opened.modal.amui', function() {\r\n  setTimeout(function() {\r\n    $(this).modal('close')\r\n  }.bind(this), 1000)\r\n})\r\n\r\n$('#username').on('change', function() {\r\n  var $username = $(this);\r\n  $username.val($.trim($username.val()).toUpperCase());\r\n})\r\n\r\n$('#validateCodeDiv').on('click', 'a', function() {\r\n  var img = $(this).prev()[0]\r\n  img.src = VALIDATA_IMG_URL + '?' + Math.random()\r\n})\r\n\r\nvar $loginBtn = $('#loginBtn')\r\n\r\nfunction effectStart() {\r\n  $.AMUI.progress.set(0.8)\r\n  $loginBtn.button('loading')\r\n}\r\n\r\nfunction effectDone() {\r\n  $.AMUI.progress.done()\r\n  $loginBtn.button('reset')\r\n}\r\n\r\n$('#loginForm').submit(function(ev) {\r\n  ev.preventDefault()\r\n\r\n  var $username = $('#username')\r\n  var $password = $('#password')\r\n  var $validate = $('#validateCode')\r\n  var pwd_str = $.trim($password.val()),\r\n      act_str = $.trim($username.val()),\r\n      vali_str = $.trim($validate.val())\r\n\r\n  if (act_str === '') {\r\n    $('#toast-cnt').html('请填写用户名')\r\n    $('#toast').modal('open')\r\n  }\r\n  else if (pwd_str === '') {\r\n    $('#toast-cnt').html('请填写密码')\r\n    $('#toast').modal('open')\r\n  }\r\n  else if ($('#validateCodeDiv').is(':visible') && vali_str === '') {\r\n    $('#toast-cnt').html('请填写验证码')\r\n    $('#toast').modal('open')\r\n  }\r\n  else {\r\n    effectStart()\r\n\r\n    var $loginForm = $(this)\r\n    if (CEIS.exponent && CEIS.modulus) {\r\n      var key = RSAUtils.getKeyPair(CEIS.exponent, '', CEIS.modulus);\r\n      var encryptedPwd = RSAUtils.encryptedString(key, pwd_str);\r\n      $password.val(encryptedPwd);\r\n    }\r\n\r\n    // $.post(LOGIN_URL, $loginForm.serializeArray(), function(data) {\r\n    //   if (data && data.sessionid) {\r\n    //     CEIS.sessionid = data.sessionid;\r\n    //     CEIS.firstLogin = data.firstLogin;\r\n    //     if (data.firstLogin) {\r\n    //       $('#toast-cnt').html('首次登陆或密码过期，请修改密码！')\r\n    //       $('#toast').modal('open')\r\n    //     }\r\n    //     else {\r\n    //       $('#toast-cnt').html('登录成功！')\r\n    //       $('#toast').modal('open')\r\n    //     }\r\n    //   }\r\n    //   else {\r\n    //     $password.val('')\r\n    //     $('#toast-cnt').html(data.message)\r\n    //     $('#toast').modal('open')\r\n    //     effectDone()\r\n    //\r\n    //     if (data.shiroLoginFailure == 'org.apache.shiro.authc.AuthenticationException'){\r\n    //       $('#validateCodeDiv').show();\r\n    //     }\r\n    //     $('#validateCodeDiv a').click();\r\n    //   }\r\n    // })\r\n\r\n    setTimeout(function() {\r\n      $.AMUI.progress.done()\r\n      document.location.href = 'index.html'\r\n    }, 1500)\r\n  }\r\n\r\n})\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app/components/login/login.js\n ** module id = 0\n ** module chunks = 2\n **/","/*\r\n * RSA, a suite of routines for performing RSA public-key computations in JavaScript.\r\n * Copyright 1998-2005 David Shapiro.\r\n * Dave Shapiro\r\n * dave@ohdave.com\r\n * changed by Fuchun, 2010-05-06\r\n * fcrpg2005@gmail.com\r\n */\r\n\r\nvar RSAUtils = {};\r\n\r\nvar biRadixBase = 2;\r\nvar biRadixBits = 16;\r\nvar bitsPerDigit = biRadixBits;\r\nvar biRadix = 1 << 16; // = 2^16 = 65536\r\nvar biHalfRadix = biRadix >>> 1;\r\nvar biRadixSquared = biRadix * biRadix;\r\nvar maxDigitVal = biRadix - 1;\r\nvar maxInteger = 9999999999999998;\r\n\r\n//maxDigits:\r\n//Change this to accommodate your largest number size. Use setMaxDigits()\r\n//to change it!\r\n//\r\n//In general, if you're working with numbers of size N bits, you'll need 2*N\r\n//bits of storage. Each digit holds 16 bits. So, a 1024-bit key will need\r\n//\r\n//1024 * 2 / 16 = 128 digits of storage.\r\n//\r\nvar maxDigits;\r\nvar ZERO_ARRAY;\r\nvar bigZero, bigOne;\r\n\r\nvar BigInt = BigInt = function(flag) {\r\n\tif (typeof flag == \"boolean\" && flag == true) {\r\n\t\tthis.digits = null;\r\n\t} else {\r\n\t\tthis.digits = ZERO_ARRAY.slice(0);\r\n\t}\r\n\tthis.isNeg = false;\r\n};\r\n\r\nRSAUtils.setMaxDigits = function(value) {\r\n\tmaxDigits = value;\r\n\tZERO_ARRAY = new Array(maxDigits);\r\n\tfor (var iza = 0; iza < ZERO_ARRAY.length; iza++) ZERO_ARRAY[iza] = 0;\r\n\tbigZero = new BigInt();\r\n\tbigOne = new BigInt();\r\n\tbigOne.digits[0] = 1;\r\n};\r\nRSAUtils.setMaxDigits(20);\r\n\r\n//The maximum number of digits in base 10 you can convert to an\r\n//integer without JavaScript throwing up on you.\r\nvar dpl10 = 15;\r\n\r\nRSAUtils.biFromNumber = function(i) {\r\n\tvar result = new BigInt();\r\n\tresult.isNeg = i < 0;\r\n\ti = Math.abs(i);\r\n\tvar j = 0;\r\n\twhile (i > 0) {\r\n\t\tresult.digits[j++] = i & maxDigitVal;\r\n\t\ti = Math.floor(i / biRadix);\r\n\t}\r\n\treturn result;\r\n};\r\n\r\n//lr10 = 10 ^ dpl10\r\nvar lr10 = RSAUtils.biFromNumber(1000000000000000);\r\n\r\nRSAUtils.biFromDecimal = function(s) {\r\n\tvar isNeg = s.charAt(0) == '-';\r\n\tvar i = isNeg ? 1 : 0;\r\n\tvar result;\r\n\t// Skip leading zeros.\r\n\twhile (i < s.length && s.charAt(i) == '0') ++i;\r\n\tif (i == s.length) {\r\n\t\tresult = new BigInt();\r\n\t}\r\n\telse {\r\n\t\tvar digitCount = s.length - i;\r\n\t\tvar fgl = digitCount % dpl10;\r\n\t\tif (fgl == 0) fgl = dpl10;\r\n\t\tresult = RSAUtils.biFromNumber(Number(s.substr(i, fgl)));\r\n\t\ti += fgl;\r\n\t\twhile (i < s.length) {\r\n\t\t\tresult = RSAUtils.biAdd(RSAUtils.biMultiply(result, lr10),\r\n\t\t\t\t\tRSAUtils.biFromNumber(Number(s.substr(i, dpl10))));\r\n\t\t\ti += dpl10;\r\n\t\t}\r\n\t\tresult.isNeg = isNeg;\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biCopy = function(bi) {\r\n\tvar result = new BigInt(true);\r\n\tresult.digits = bi.digits.slice(0);\r\n\tresult.isNeg = bi.isNeg;\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.reverseStr = function(s) {\r\n\tvar result = \"\";\r\n\tfor (var i = s.length - 1; i > -1; --i) {\r\n\t\tresult += s.charAt(i);\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nvar hexatrigesimalToChar = [\r\n\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\r\n\t'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\r\n\t'u', 'v', 'w', 'x', 'y', 'z'\r\n];\r\n\r\nRSAUtils.biToString = function(x, radix) { // 2 <= radix <= 36\r\n\tvar b = new BigInt();\r\n\tb.digits[0] = radix;\r\n\tvar qr = RSAUtils.biDivideModulo(x, b);\r\n\tvar result = hexatrigesimalToChar[qr[1].digits[0]];\r\n\twhile (RSAUtils.biCompare(qr[0], bigZero) == 1) {\r\n\t\tqr = RSAUtils.biDivideModulo(qr[0], b);\r\n\t\tdigit = qr[1].digits[0];\r\n\t\tresult += hexatrigesimalToChar[qr[1].digits[0]];\r\n\t}\r\n\treturn (x.isNeg ? \"-\" : \"\") + RSAUtils.reverseStr(result);\r\n};\r\n\r\nRSAUtils.biToDecimal = function(x) {\r\n\tvar b = new BigInt();\r\n\tb.digits[0] = 10;\r\n\tvar qr = RSAUtils.biDivideModulo(x, b);\r\n\tvar result = String(qr[1].digits[0]);\r\n\twhile (RSAUtils.biCompare(qr[0], bigZero) == 1) {\r\n\t\tqr = RSAUtils.biDivideModulo(qr[0], b);\r\n\t\tresult += String(qr[1].digits[0]);\r\n\t}\r\n\treturn (x.isNeg ? \"-\" : \"\") + RSAUtils.reverseStr(result);\r\n};\r\n\r\nvar hexToChar = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n        'a', 'b', 'c', 'd', 'e', 'f'];\r\n\r\nRSAUtils.digitToHex = function(n) {\r\n\tvar mask = 0xf;\r\n\tvar result = \"\";\r\n\tfor (i = 0; i < 4; ++i) {\r\n\t\tresult += hexToChar[n & mask];\r\n\t\tn >>>= 4;\r\n\t}\r\n\treturn RSAUtils.reverseStr(result);\r\n};\r\n\r\nRSAUtils.biToHex = function(x) {\r\n\tvar result = \"\";\r\n\tvar n = RSAUtils.biHighIndex(x);\r\n\tfor (var i = RSAUtils.biHighIndex(x); i > -1; --i) {\r\n\t\tresult += RSAUtils.digitToHex(x.digits[i]);\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.charToHex = function(c) {\r\n\tvar ZERO = 48;\r\n\tvar NINE = ZERO + 9;\r\n\tvar littleA = 97;\r\n\tvar littleZ = littleA + 25;\r\n\tvar bigA = 65;\r\n\tvar bigZ = 65 + 25;\r\n\tvar result;\r\n\r\n\tif (c >= ZERO && c <= NINE) {\r\n\t\tresult = c - ZERO;\r\n\t} else if (c >= bigA && c <= bigZ) {\r\n\t\tresult = 10 + c - bigA;\r\n\t} else if (c >= littleA && c <= littleZ) {\r\n\t\tresult = 10 + c - littleA;\r\n\t} else {\r\n\t\tresult = 0;\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.hexToDigit = function(s) {\r\n\tvar result = 0;\r\n\tvar sl = Math.min(s.length, 4);\r\n\tfor (var i = 0; i < sl; ++i) {\r\n\t\tresult <<= 4;\r\n\t\tresult |= RSAUtils.charToHex(s.charCodeAt(i));\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biFromHex = function(s) {\r\n\tvar result = new BigInt();\r\n\tvar sl = s.length;\r\n\tfor (var i = sl, j = 0; i > 0; i -= 4, ++j) {\r\n\t\tresult.digits[j] = RSAUtils.hexToDigit(s.substr(Math.max(i - 4, 0), Math.min(i, 4)));\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biFromString = function(s, radix) {\r\n\tvar isNeg = s.charAt(0) == '-';\r\n\tvar istop = isNeg ? 1 : 0;\r\n\tvar result = new BigInt();\r\n\tvar place = new BigInt();\r\n\tplace.digits[0] = 1; // radix^0\r\n\tfor (var i = s.length - 1; i >= istop; i--) {\r\n\t\tvar c = s.charCodeAt(i);\r\n\t\tvar digit = RSAUtils.charToHex(c);\r\n\t\tvar biDigit = RSAUtils.biMultiplyDigit(place, digit);\r\n\t\tresult = RSAUtils.biAdd(result, biDigit);\r\n\t\tplace = RSAUtils.biMultiplyDigit(place, radix);\r\n\t}\r\n\tresult.isNeg = isNeg;\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biDump = function(b) {\r\n\treturn (b.isNeg ? \"-\" : \"\") + b.digits.join(\" \");\r\n};\r\n\r\nRSAUtils.biAdd = function(x, y) {\r\n\tvar result;\r\n\r\n\tif (x.isNeg != y.isNeg) {\r\n\t\ty.isNeg = !y.isNeg;\r\n\t\tresult = RSAUtils.biSubtract(x, y);\r\n\t\ty.isNeg = !y.isNeg;\r\n\t}\r\n\telse {\r\n\t\tresult = new BigInt();\r\n\t\tvar c = 0;\r\n\t\tvar n;\r\n\t\tfor (var i = 0; i < x.digits.length; ++i) {\r\n\t\t\tn = x.digits[i] + y.digits[i] + c;\r\n\t\t\tresult.digits[i] = n % biRadix;\r\n\t\t\tc = Number(n >= biRadix);\r\n\t\t}\r\n\t\tresult.isNeg = x.isNeg;\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biSubtract = function(x, y) {\r\n\tvar result;\r\n\tif (x.isNeg != y.isNeg) {\r\n\t\ty.isNeg = !y.isNeg;\r\n\t\tresult = RSAUtils.biAdd(x, y);\r\n\t\ty.isNeg = !y.isNeg;\r\n\t} else {\r\n\t\tresult = new BigInt();\r\n\t\tvar n, c;\r\n\t\tc = 0;\r\n\t\tfor (var i = 0; i < x.digits.length; ++i) {\r\n\t\t\tn = x.digits[i] - y.digits[i] + c;\r\n\t\t\tresult.digits[i] = n % biRadix;\r\n\t\t\t// Stupid non-conforming modulus operation.\r\n\t\t\tif (result.digits[i] < 0) result.digits[i] += biRadix;\r\n\t\t\tc = 0 - Number(n < 0);\r\n\t\t}\r\n\t\t// Fix up the negative sign, if any.\r\n\t\tif (c == -1) {\r\n\t\t\tc = 0;\r\n\t\t\tfor (var i = 0; i < x.digits.length; ++i) {\r\n\t\t\t\tn = 0 - result.digits[i] + c;\r\n\t\t\t\tresult.digits[i] = n % biRadix;\r\n\t\t\t\t// Stupid non-conforming modulus operation.\r\n\t\t\t\tif (result.digits[i] < 0) result.digits[i] += biRadix;\r\n\t\t\t\tc = 0 - Number(n < 0);\r\n\t\t\t}\r\n\t\t\t// Result is opposite sign of arguments.\r\n\t\t\tresult.isNeg = !x.isNeg;\r\n\t\t} else {\r\n\t\t\t// Result is same sign.\r\n\t\t\tresult.isNeg = x.isNeg;\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biHighIndex = function(x) {\r\n\tvar result = x.digits.length - 1;\r\n\twhile (result > 0 && x.digits[result] == 0) --result;\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biNumBits = function(x) {\r\n\tvar n = RSAUtils.biHighIndex(x);\r\n\tvar d = x.digits[n];\r\n\tvar m = (n + 1) * bitsPerDigit;\r\n\tvar result;\r\n\tfor (result = m; result > m - bitsPerDigit; --result) {\r\n\t\tif ((d & 0x8000) != 0) break;\r\n\t\td <<= 1;\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biMultiply = function(x, y) {\r\n\tvar result = new BigInt();\r\n\tvar c;\r\n\tvar n = RSAUtils.biHighIndex(x);\r\n\tvar t = RSAUtils.biHighIndex(y);\r\n\tvar u, uv, k;\r\n\r\n\tfor (var i = 0; i <= t; ++i) {\r\n\t\tc = 0;\r\n\t\tk = i;\r\n\t\tfor (j = 0; j <= n; ++j, ++k) {\r\n\t\t\tuv = result.digits[k] + x.digits[j] * y.digits[i] + c;\r\n\t\t\tresult.digits[k] = uv & maxDigitVal;\r\n\t\t\tc = uv >>> biRadixBits;\r\n\t\t\t//c = Math.floor(uv / biRadix);\r\n\t\t}\r\n\t\tresult.digits[i + n + 1] = c;\r\n\t}\r\n\t// Someone give me a logical xor, please.\r\n\tresult.isNeg = x.isNeg != y.isNeg;\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biMultiplyDigit = function(x, y) {\r\n\tvar n, c, uv;\r\n\r\n\tresult = new BigInt();\r\n\tn = RSAUtils.biHighIndex(x);\r\n\tc = 0;\r\n\tfor (var j = 0; j <= n; ++j) {\r\n\t\tuv = result.digits[j] + x.digits[j] * y + c;\r\n\t\tresult.digits[j] = uv & maxDigitVal;\r\n\t\tc = uv >>> biRadixBits;\r\n\t\t//c = Math.floor(uv / biRadix);\r\n\t}\r\n\tresult.digits[1 + n] = c;\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.arrayCopy = function(src, srcStart, dest, destStart, n) {\r\n\tvar m = Math.min(srcStart + n, src.length);\r\n\tfor (var i = srcStart, j = destStart; i < m; ++i, ++j) {\r\n\t\tdest[j] = src[i];\r\n\t}\r\n};\r\n\r\nvar highBitMasks = [0x0000, 0x8000, 0xC000, 0xE000, 0xF000, 0xF800,\r\n        0xFC00, 0xFE00, 0xFF00, 0xFF80, 0xFFC0, 0xFFE0,\r\n        0xFFF0, 0xFFF8, 0xFFFC, 0xFFFE, 0xFFFF];\r\n\r\nRSAUtils.biShiftLeft = function(x, n) {\r\n\tvar digitCount = Math.floor(n / bitsPerDigit);\r\n\tvar result = new BigInt();\r\n\tRSAUtils.arrayCopy(x.digits, 0, result.digits, digitCount,\r\n\t          result.digits.length - digitCount);\r\n\tvar bits = n % bitsPerDigit;\r\n\tvar rightBits = bitsPerDigit - bits;\r\n\tfor (var i = result.digits.length - 1, i1 = i - 1; i > 0; --i, --i1) {\r\n\t\tresult.digits[i] = ((result.digits[i] << bits) & maxDigitVal) |\r\n\t\t                   ((result.digits[i1] & highBitMasks[bits]) >>>\r\n\t\t                    (rightBits));\r\n\t}\r\n\tresult.digits[0] = ((result.digits[i] << bits) & maxDigitVal);\r\n\tresult.isNeg = x.isNeg;\r\n\treturn result;\r\n};\r\n\r\nvar lowBitMasks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F,\r\n        0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF,\r\n        0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];\r\n\r\nRSAUtils.biShiftRight = function(x, n) {\r\n\tvar digitCount = Math.floor(n / bitsPerDigit);\r\n\tvar result = new BigInt();\r\n\tRSAUtils.arrayCopy(x.digits, digitCount, result.digits, 0,\r\n\t          x.digits.length - digitCount);\r\n\tvar bits = n % bitsPerDigit;\r\n\tvar leftBits = bitsPerDigit - bits;\r\n\tfor (var i = 0, i1 = i + 1; i < result.digits.length - 1; ++i, ++i1) {\r\n\t\tresult.digits[i] = (result.digits[i] >>> bits) |\r\n\t\t                   ((result.digits[i1] & lowBitMasks[bits]) << leftBits);\r\n\t}\r\n\tresult.digits[result.digits.length - 1] >>>= bits;\r\n\tresult.isNeg = x.isNeg;\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biMultiplyByRadixPower = function(x, n) {\r\n\tvar result = new BigInt();\r\n\tRSAUtils.arrayCopy(x.digits, 0, result.digits, n, result.digits.length - n);\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biDivideByRadixPower = function(x, n) {\r\n\tvar result = new BigInt();\r\n\tRSAUtils.arrayCopy(x.digits, n, result.digits, 0, result.digits.length - n);\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biModuloByRadixPower = function(x, n) {\r\n\tvar result = new BigInt();\r\n\tRSAUtils.arrayCopy(x.digits, 0, result.digits, 0, n);\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biCompare = function(x, y) {\r\n\tif (x.isNeg != y.isNeg) {\r\n\t\treturn 1 - 2 * Number(x.isNeg);\r\n\t}\r\n\tfor (var i = x.digits.length - 1; i >= 0; --i) {\r\n\t\tif (x.digits[i] != y.digits[i]) {\r\n\t\t\tif (x.isNeg) {\r\n\t\t\t\treturn 1 - 2 * Number(x.digits[i] > y.digits[i]);\r\n\t\t\t} else {\r\n\t\t\t\treturn 1 - 2 * Number(x.digits[i] < y.digits[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n};\r\n\r\nRSAUtils.biDivideModulo = function(x, y) {\r\n\tvar nb = RSAUtils.biNumBits(x);\r\n\tvar tb = RSAUtils.biNumBits(y);\r\n\tvar origYIsNeg = y.isNeg;\r\n\tvar q, r;\r\n\tif (nb < tb) {\r\n\t\t// |x| < |y|\r\n\t\tif (x.isNeg) {\r\n\t\t\tq = RSAUtils.biCopy(bigOne);\r\n\t\t\tq.isNeg = !y.isNeg;\r\n\t\t\tx.isNeg = false;\r\n\t\t\ty.isNeg = false;\r\n\t\t\tr = biSubtract(y, x);\r\n\t\t\t// Restore signs, 'cause they're references.\r\n\t\t\tx.isNeg = true;\r\n\t\t\ty.isNeg = origYIsNeg;\r\n\t\t} else {\r\n\t\t\tq = new BigInt();\r\n\t\t\tr = RSAUtils.biCopy(x);\r\n\t\t}\r\n\t\treturn [q, r];\r\n\t}\r\n\r\n\tq = new BigInt();\r\n\tr = x;\r\n\r\n\t// Normalize Y.\r\n\tvar t = Math.ceil(tb / bitsPerDigit) - 1;\r\n\tvar lambda = 0;\r\n\twhile (y.digits[t] < biHalfRadix) {\r\n\t\ty = RSAUtils.biShiftLeft(y, 1);\r\n\t\t++lambda;\r\n\t\t++tb;\r\n\t\tt = Math.ceil(tb / bitsPerDigit) - 1;\r\n\t}\r\n\t// Shift r over to keep the quotient constant. We'll shift the\r\n\t// remainder back at the end.\r\n\tr = RSAUtils.biShiftLeft(r, lambda);\r\n\tnb += lambda; // Update the bit count for x.\r\n\tvar n = Math.ceil(nb / bitsPerDigit) - 1;\r\n\r\n\tvar b = RSAUtils.biMultiplyByRadixPower(y, n - t);\r\n\twhile (RSAUtils.biCompare(r, b) != -1) {\r\n\t\t++q.digits[n - t];\r\n\t\tr = RSAUtils.biSubtract(r, b);\r\n\t}\r\n\tfor (var i = n; i > t; --i) {\r\n    var ri = (i >= r.digits.length) ? 0 : r.digits[i];\r\n    var ri1 = (i - 1 >= r.digits.length) ? 0 : r.digits[i - 1];\r\n    var ri2 = (i - 2 >= r.digits.length) ? 0 : r.digits[i - 2];\r\n    var yt = (t >= y.digits.length) ? 0 : y.digits[t];\r\n    var yt1 = (t - 1 >= y.digits.length) ? 0 : y.digits[t - 1];\r\n\t\tif (ri == yt) {\r\n\t\t\tq.digits[i - t - 1] = maxDigitVal;\r\n\t\t} else {\r\n\t\t\tq.digits[i - t - 1] = Math.floor((ri * biRadix + ri1) / yt);\r\n\t\t}\r\n\r\n\t\tvar c1 = q.digits[i - t - 1] * ((yt * biRadix) + yt1);\r\n\t\tvar c2 = (ri * biRadixSquared) + ((ri1 * biRadix) + ri2);\r\n\t\twhile (c1 > c2) {\r\n\t\t\t--q.digits[i - t - 1];\r\n\t\t\tc1 = q.digits[i - t - 1] * ((yt * biRadix) | yt1);\r\n\t\t\tc2 = (ri * biRadix * biRadix) + ((ri1 * biRadix) + ri2);\r\n\t\t}\r\n\r\n\t\tb = RSAUtils.biMultiplyByRadixPower(y, i - t - 1);\r\n\t\tr = RSAUtils.biSubtract(r, RSAUtils.biMultiplyDigit(b, q.digits[i - t - 1]));\r\n\t\tif (r.isNeg) {\r\n\t\t\tr = RSAUtils.biAdd(r, b);\r\n\t\t\t--q.digits[i - t - 1];\r\n\t\t}\r\n\t}\r\n\tr = RSAUtils.biShiftRight(r, lambda);\r\n\t// Fiddle with the signs and stuff to make sure that 0 <= r < y.\r\n\tq.isNeg = x.isNeg != origYIsNeg;\r\n\tif (x.isNeg) {\r\n\t\tif (origYIsNeg) {\r\n\t\t\tq = RSAUtils.biAdd(q, bigOne);\r\n\t\t} else {\r\n\t\t\tq = RSAUtils.biSubtract(q, bigOne);\r\n\t\t}\r\n\t\ty = RSAUtils.biShiftRight(y, lambda);\r\n\t\tr = RSAUtils.biSubtract(y, r);\r\n\t}\r\n\t// Check for the unbelievably stupid degenerate case of r == -0.\r\n\tif (r.digits[0] == 0 && RSAUtils.biHighIndex(r) == 0) r.isNeg = false;\r\n\r\n\treturn [q, r];\r\n};\r\n\r\nRSAUtils.biDivide = function(x, y) {\r\n\treturn RSAUtils.biDivideModulo(x, y)[0];\r\n};\r\n\r\nRSAUtils.biModulo = function(x, y) {\r\n\treturn RSAUtils.biDivideModulo(x, y)[1];\r\n};\r\n\r\nRSAUtils.biMultiplyMod = function(x, y, m) {\r\n\treturn RSAUtils.biModulo(RSAUtils.biMultiply(x, y), m);\r\n};\r\n\r\nRSAUtils.biPow = function(x, y) {\r\n\tvar result = bigOne;\r\n\tvar a = x;\r\n\twhile (true) {\r\n\t\tif ((y & 1) != 0) result = RSAUtils.biMultiply(result, a);\r\n\t\ty >>= 1;\r\n\t\tif (y == 0) break;\r\n\t\ta = RSAUtils.biMultiply(a, a);\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.biPowMod = function(x, y, m) {\r\n\tvar result = bigOne;\r\n\tvar a = x;\r\n\tvar k = y;\r\n\twhile (true) {\r\n\t\tif ((k.digits[0] & 1) != 0) result = RSAUtils.biMultiplyMod(result, a, m);\r\n\t\tk = RSAUtils.biShiftRight(k, 1);\r\n\t\tif (k.digits[0] == 0 && RSAUtils.biHighIndex(k) == 0) break;\r\n\t\ta = RSAUtils.biMultiplyMod(a, a, m);\r\n\t}\r\n\treturn result;\r\n};\r\n\r\n\r\nBarrettMu = function(m) {\r\n\tthis.modulus = RSAUtils.biCopy(m);\r\n\tthis.k = RSAUtils.biHighIndex(this.modulus) + 1;\r\n\tvar b2k = new BigInt();\r\n\tb2k.digits[2 * this.k] = 1; // b2k = b^(2k)\r\n\tthis.mu = RSAUtils.biDivide(b2k, this.modulus);\r\n\tthis.bkplus1 = new BigInt();\r\n\tthis.bkplus1.digits[this.k + 1] = 1; // bkplus1 = b^(k+1)\r\n\tthis.modulo = BarrettMu_modulo;\r\n\tthis.multiplyMod = BarrettMu_multiplyMod;\r\n\tthis.powMod = BarrettMu_powMod;\r\n};\r\n\r\nfunction BarrettMu_modulo(x) {\r\n\tvar $dmath = RSAUtils;\r\n\tvar q1 = $dmath.biDivideByRadixPower(x, this.k - 1);\r\n\tvar q2 = $dmath.biMultiply(q1, this.mu);\r\n\tvar q3 = $dmath.biDivideByRadixPower(q2, this.k + 1);\r\n\tvar r1 = $dmath.biModuloByRadixPower(x, this.k + 1);\r\n\tvar r2term = $dmath.biMultiply(q3, this.modulus);\r\n\tvar r2 = $dmath.biModuloByRadixPower(r2term, this.k + 1);\r\n\tvar r = $dmath.biSubtract(r1, r2);\r\n\tif (r.isNeg) {\r\n\t\tr = $dmath.biAdd(r, this.bkplus1);\r\n\t}\r\n\tvar rgtem = $dmath.biCompare(r, this.modulus) >= 0;\r\n\twhile (rgtem) {\r\n\t\tr = $dmath.biSubtract(r, this.modulus);\r\n\t\trgtem = $dmath.biCompare(r, this.modulus) >= 0;\r\n\t}\r\n\treturn r;\r\n}\r\n\r\nfunction BarrettMu_multiplyMod(x, y) {\r\n\t/*\r\n\tx = this.modulo(x);\r\n\ty = this.modulo(y);\r\n\t*/\r\n\tvar xy = RSAUtils.biMultiply(x, y);\r\n\treturn this.modulo(xy);\r\n}\r\n\r\nfunction BarrettMu_powMod(x, y) {\r\n\tvar result = new BigInt();\r\n\tresult.digits[0] = 1;\r\n\tvar a = x;\r\n\tvar k = y;\r\n\twhile (true) {\r\n\t\tif ((k.digits[0] & 1) != 0) result = this.multiplyMod(result, a);\r\n\t\tk = RSAUtils.biShiftRight(k, 1);\r\n\t\tif (k.digits[0] == 0 && RSAUtils.biHighIndex(k) == 0) break;\r\n\t\ta = this.multiplyMod(a, a);\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nvar RSAKeyPair = function(encryptionExponent, decryptionExponent, modulus) {\r\n\tvar $dmath = RSAUtils;\r\n\tthis.e = $dmath.biFromHex(encryptionExponent);\r\n\tthis.d = $dmath.biFromHex(decryptionExponent);\r\n\tthis.m = $dmath.biFromHex(modulus);\r\n\t// We can do two bytes per digit, so\r\n\t// chunkSize = 2 * (number of digits in modulus - 1).\r\n\t// Since biHighIndex returns the high index, not the number of digits, 1 has\r\n\t// already been subtracted.\r\n\tthis.chunkSize = 2 * $dmath.biHighIndex(this.m);\r\n\tthis.radix = 16;\r\n\tthis.barrett = new BarrettMu(this.m);\r\n};\r\n\r\nRSAUtils.getKeyPair = function(encryptionExponent, decryptionExponent, modulus) {\r\n\treturn new RSAKeyPair(encryptionExponent, decryptionExponent, modulus);\r\n};\r\n\r\nif(typeof twoDigit === 'undefined') {\r\n\ttwoDigit = function(n) {\r\n\t\treturn (n < 10 ? \"0\" : \"\") + String(n);\r\n\t};\r\n}\r\n\r\n// Altered by Rob Saunders (rob@robsaunders.net). New routine pads the\r\n// string after it has been converted to an array. This fixes an\r\n// incompatibility with Flash MX's ActionScript.\r\nRSAUtils.encryptedString = function(key, s) {\r\n\tvar a = [];\r\n\tvar sl = s.length;\r\n\tvar i = 0;\r\n\twhile (i < sl) {\r\n\t\ta[i] = s.charCodeAt(i);\r\n\t\ti++;\r\n\t}\r\n\r\n\twhile (a.length % key.chunkSize != 0) {\r\n\t\ta[i++] = 0;\r\n\t}\r\n\r\n\tvar al = a.length;\r\n\tvar result = \"\";\r\n\tvar j, k, block;\r\n\tfor (i = 0; i < al; i += key.chunkSize) {\r\n\t\tblock = new BigInt();\r\n\t\tj = 0;\r\n\t\tfor (k = i; k < i + key.chunkSize; ++j) {\r\n\t\t\tblock.digits[j] = a[k++];\r\n\t\t\tblock.digits[j] += a[k++] << 8;\r\n\t\t}\r\n\t\tvar crypt = key.barrett.powMod(block, key.e);\r\n\t\tvar text = key.radix == 16 ? RSAUtils.biToHex(crypt) : RSAUtils.biToString(crypt, key.radix);\r\n\t\tresult += text + \" \";\r\n\t}\r\n\treturn result.substring(0, result.length - 1); // Remove last space.\r\n};\r\n\r\nRSAUtils.decryptedString = function(key, s) {\r\n\tvar blocks = s.split(\" \");\r\n\tvar result = \"\";\r\n\tvar i, j, block;\r\n\tfor (i = 0; i < blocks.length; ++i) {\r\n\t\tvar bi;\r\n\t\tif (key.radix == 16) {\r\n\t\t\tbi = RSAUtils.biFromHex(blocks[i]);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tbi = RSAUtils.biFromString(blocks[i], key.radix);\r\n\t\t}\r\n\t\tblock = key.barrett.powMod(bi, key.d);\r\n\t\tfor (j = 0; j <= RSAUtils.biHighIndex(block); ++j) {\r\n\t\t\tresult += String.fromCharCode(block.digits[j] & 255,\r\n\t\t\t                              block.digits[j] >> 8);\r\n\t\t}\r\n\t}\r\n\t// Remove trailing null, if any.\r\n\tif (result.charCodeAt(result.length - 1) == 0) {\r\n\t\tresult = result.substring(0, result.length - 1);\r\n\t}\r\n\treturn result;\r\n};\r\n\r\nRSAUtils.setMaxDigits(130);\r\n\r\nmodule.exports = RSAUtils;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app/components/login/rsautils.js\n ** module id = 13\n ** module chunks = 2\n **/"],"sourceRoot":""}